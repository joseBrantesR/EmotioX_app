var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.jsx
var src_exports = {};
__export(src_exports, {
  createHorizontalStrength: () => createHorizontalStrength,
  createVerticalStrength: () => createVerticalStrength,
  default: () => createScrollingComponent,
  defaultHorizontalStrength: () => defaultHorizontalStrength,
  defaultVerticalStrength: () => defaultVerticalStrength,
  useDndScrolling: () => useDndScrolling
});
module.exports = __toCommonJS(src_exports);
var import_react = __toESM(require("react"), 1);
var import_prop_types = __toESM(require("prop-types"), 1);
var import_react_dnd = require("react-dnd");
var import_hoist_non_react_statics = __toESM(require("hoist-non-react-statics"), 1);

// src/util.js
function noop() {
}
function intBetween(min, max, val) {
  return Math.floor(Math.min(max, Math.max(min, val)));
}
function getCoords(evt) {
  if (evt.type === "touchmove") {
    return { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
  }
  return { x: evt.clientX, y: evt.clientY };
}

// src/ScrollingMonitor.js
var import_lodash = __toESM(require("lodash.throttle"), 1);
var import_raf = __toESM(require("raf"), 1);
var ScrollingMonitor = class {
  constructor(dragDropManager, container, options) {
    this.dragDropManager = dragDropManager;
    this.container = container;
    this.eventBody = container.ownerDocument.body;
    this.options = options;
    this.scaleX = 0;
    this.scaleY = 0;
    this.frame = null;
    this.attached = false;
    this.dragging = false;
  }
  start() {
    this.container.addEventListener("dragover", this.handleEvent);
    this.eventBody.addEventListener("touchmove", this.handleEvent);
    this.clearMonitorSubscription = this.dragDropManager.getMonitor().subscribeToStateChange(() => this.handleMonitorChange());
  }
  stop() {
    this.container.removeEventListener("dragover", this.handleEvent);
    this.eventBody.removeEventListener("touchmove", this.handleEvent);
    this.clearMonitorSubscription();
    this.stopScrolling();
  }
  handleEvent = (evt) => {
    if (this.dragging && !this.attached) {
      this.attach();
      this.updateScrolling(evt);
    }
  };
  handleMonitorChange() {
    const isDragging = this.dragDropManager.getMonitor().isDragging();
    if (!this.dragging && isDragging) {
      this.dragging = true;
    } else if (this.dragging && !isDragging) {
      this.dragging = false;
      this.stopScrolling();
    }
  }
  attach() {
    this.attached = true;
    this.eventBody.addEventListener("dragover", this.updateScrolling);
    this.eventBody.addEventListener("touchmove", this.updateScrolling);
  }
  detach() {
    this.attached = false;
    this.eventBody.removeEventListener("dragover", this.updateScrolling);
    this.eventBody.removeEventListener("touchmove", this.updateScrolling);
  }
  // Update scaleX and scaleY every 100ms or so
  // and start scrolling if necessary
  updateScrolling = (0, import_lodash.default)(
    (evt) => {
      const {
        left: x,
        top: y,
        width: w,
        height: h
      } = this.container.getBoundingClientRect();
      const box = { x, y, w, h };
      const coords = getCoords(evt);
      this.scaleX = this.options.horizontalStrength(box, coords);
      this.scaleY = this.options.verticalStrength(box, coords);
      if (!this.frame && (this.scaleX || this.scaleY)) {
        this.startScrolling();
      }
    },
    100,
    { trailing: false }
  );
  startScrolling() {
    let i = 0;
    const tick = () => {
      const { scaleX, scaleY, container } = this;
      const { strengthMultiplier, onScrollChange } = this.options;
      if (strengthMultiplier === 0 || scaleX + scaleY === 0) {
        this.stopScrolling();
        return;
      }
      if (i++ % 2) {
        const {
          scrollLeft,
          scrollTop,
          scrollWidth,
          scrollHeight,
          clientWidth,
          clientHeight
        } = container;
        const newLeft = scaleX ? container.scrollLeft = intBetween(
          0,
          scrollWidth - clientWidth,
          scrollLeft + scaleX * strengthMultiplier
        ) : scrollLeft;
        const newTop = scaleY ? container.scrollTop = intBetween(
          0,
          scrollHeight - clientHeight,
          scrollTop + scaleY * strengthMultiplier
        ) : scrollTop;
        onScrollChange(newLeft, newTop);
      }
      this.frame = (0, import_raf.default)(tick);
    };
    tick();
  }
  stopScrolling() {
    this.detach();
    this.scaleX = 0;
    this.scaleY = 0;
    if (this.frame) {
      import_raf.default.cancel(this.frame);
      this.frame = null;
    }
  }
};

// src/index.jsx
var DEFAULT_BUFFER = 150;
var getDisplayName = (PassedComponent) => PassedComponent.displayName || PassedComponent.name || (typeof PassedComponent === "string" && PassedComponent.length > 0 ? PassedComponent : "Unknown");
function createHorizontalStrength(_buffer) {
  return function defaultHorizontalStrength2({ x, w, y, h }, point) {
    const buffer = Math.min(w / 2, _buffer);
    const inRange = point.x >= x && point.x <= x + w;
    const inBox = inRange && point.y >= y && point.y <= y + h;
    if (inBox) {
      if (point.x < x + buffer) {
        return (point.x - x - buffer) / buffer;
      } else if (point.x > x + w - buffer) {
        return -(x + w - point.x - buffer) / buffer;
      }
    }
    return 0;
  };
}
function createVerticalStrength(_buffer) {
  return function defaultVerticalStrength2({ y, h, x, w }, point) {
    const buffer = Math.min(h / 2, _buffer);
    const inRange = point.y >= y && point.y <= y + h;
    const inBox = inRange && point.x >= x && point.x <= x + w;
    if (inBox) {
      if (point.y < y + buffer) {
        return (point.y - y - buffer) / buffer;
      } else if (point.y > y + h - buffer) {
        return -(y + h - point.y - buffer) / buffer;
      }
    }
    return 0;
  };
}
var defaultHorizontalStrength = createHorizontalStrength(DEFAULT_BUFFER);
var defaultVerticalStrength = createVerticalStrength(DEFAULT_BUFFER);
var defaultOptions = {
  onScrollChange: noop,
  verticalStrength: defaultVerticalStrength,
  horizontalStrength: defaultHorizontalStrength,
  strengthMultiplier: 30
};
function useDndScrolling(componentRef, passedOptions) {
  const { dragDropManager } = (0, import_react.useContext)(import_react_dnd.DndContext);
  if (!dragDropManager) {
    throw new Error(
      "Unable to get dragDropManager from context. Wrap this in <DndProvider>."
    );
  }
  (0, import_react.useEffect)(() => {
    if (!componentRef.current) {
      return () => {
      };
    }
    const options = { ...defaultOptions, ...passedOptions };
    const monitor = new ScrollingMonitor(dragDropManager, componentRef.current, options);
    monitor.start();
    return () => {
      monitor.stop();
    };
  }, [componentRef.current, dragDropManager, passedOptions]);
}
function createScrollingComponent(WrappedComponent) {
  function ScrollingComponent({
    strengthMultiplier,
    verticalStrength,
    horizontalStrength,
    onScrollChange,
    ...passedProps
  }) {
    const ref = (0, import_react.useRef)(null);
    useDndScrolling(ref, {
      strengthMultiplier,
      verticalStrength,
      horizontalStrength,
      onScrollChange
    });
    return /* @__PURE__ */ import_react.default.createElement(WrappedComponent, { ...passedProps, ref });
  }
  ScrollingComponent.displayName = `Scrolling(${getDisplayName(WrappedComponent)})`;
  ScrollingComponent.propTypes = {
    onScrollChange: import_prop_types.default.func,
    verticalStrength: import_prop_types.default.func,
    horizontalStrength: import_prop_types.default.func,
    strengthMultiplier: import_prop_types.default.number
  };
  ScrollingComponent.defaultProps = defaultOptions;
  return (0, import_hoist_non_react_statics.default)(ScrollingComponent, WrappedComponent);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createHorizontalStrength,
  createVerticalStrength,
  defaultHorizontalStrength,
  defaultVerticalStrength,
  useDndScrolling
});
//# sourceMappingURL=index.cjs.map