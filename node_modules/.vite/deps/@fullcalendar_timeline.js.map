{
  "version": 3,
  "sources": ["../../@fullcalendar/premium-common/index.js", "../../@fullcalendar/scrollgrid/internal.js", "../../@fullcalendar/timeline/internal.js", "../../@fullcalendar/timeline/index.js"],
  "sourcesContent": ["import { createPlugin } from '@fullcalendar/core/index.js';\nimport { config, isValidDate, addDays } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment } from '@fullcalendar/core/preact.js';\n\nconst UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too\nconst INVALID_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#invalid';\nconst OUTDATED_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#outdated';\nconst PRESET_LICENSE_KEYS = [\n    'GPL-My-Project-Is-Open-Source',\n    'CC-Attribution-NonCommercial-NoDerivatives',\n];\nconst CSS = {\n    position: 'absolute',\n    zIndex: 99999,\n    bottom: '1px',\n    left: '1px',\n    background: '#eee',\n    borderColor: '#ddd',\n    borderStyle: 'solid',\n    borderWidth: '1px 1px 0 0',\n    padding: '2px 4px',\n    fontSize: '12px',\n    borderTopRightRadius: '3px',\n};\nfunction buildLicenseWarning(context) {\n    let key = context.options.schedulerLicenseKey;\n    let currentUrl = typeof window !== 'undefined' ? window.location.href : '';\n    if (!isImmuneUrl(currentUrl)) {\n        let status = processLicenseKey(key, context.pluginHooks.premiumReleaseDate);\n        if (status !== 'valid') {\n            return (createElement(\"div\", { className: \"fc-license-message\", style: CSS }, (status === 'outdated') ? (createElement(Fragment, null,\n                'Your license key is too old to work with this version. ',\n                createElement(\"a\", { href: OUTDATED_LICENSE_URL }, \"More Info\"))) : (createElement(Fragment, null,\n                'Your license key is invalid. ',\n                createElement(\"a\", { href: INVALID_LICENSE_URL }, \"More Info\")))));\n        }\n    }\n    return null;\n}\n/*\nThis decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\n*/\nfunction processLicenseKey(key, premiumReleaseDate) {\n    if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {\n        return 'valid';\n    }\n    const parts = (key || '').match(/^(\\d+)-fcs-(\\d+)$/);\n    if (parts && (parts[1].length === 10)) {\n        const purchaseDate = new Date(parseInt(parts[2], 10) * 1000);\n        const releaseDate = config.mockSchedulerReleaseDate || premiumReleaseDate;\n        if (isValidDate(releaseDate)) { // token won't be replaced in dev mode\n            const minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);\n            if (minPurchaseDate < purchaseDate) {\n                return 'valid';\n            }\n            return 'outdated';\n        }\n    }\n    return 'invalid';\n}\nfunction isImmuneUrl(url) {\n    return /\\w+:\\/\\/fullcalendar\\.io\\/|\\/examples\\/[\\w-]+\\.html$/.test(url);\n}\n\nconst OPTION_REFINERS = {\n    schedulerLicenseKey: String,\n};\n\nvar index = createPlugin({\n    name: '@fullcalendar/premium-common',\n    premiumReleaseDate: '2024-07-12',\n    optionRefiners: OPTION_REFINERS,\n    viewContainerAppends: [buildLicenseWarning],\n});\n\nexport { index as default };\n", "import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n    let rect = scrollEl.getBoundingClientRect();\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n    return {\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\n    };\n}\nfunction getScrollFromLeftEdge(el) {\n    let scrollLeft = el.scrollLeft;\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'negative':\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n        }\n    }\n    return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'reverse':\n                scrollLeft = el.scrollWidth - scrollLeft;\n                break;\n            case 'negative':\n                scrollLeft = -(el.scrollWidth - scrollLeft);\n                break;\n        }\n    }\n    el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '-1000px';\n    el.style.width = '100px'; // must be at least the side of scrollbars or you get inaccurate values (#7335)\n    el.style.height = '100px'; // \"\n    el.style.overflow = 'scroll';\n    el.style.direction = 'rtl';\n    let innerEl = document.createElement('div');\n    innerEl.style.width = '200px';\n    innerEl.style.height = '200px';\n    el.appendChild(innerEl);\n    document.body.appendChild(el);\n    let system;\n    if (el.scrollLeft > 0) {\n        system = 'positive'; // scroll is a positive number from the left edge\n    }\n    else {\n        el.scrollLeft = 1;\n        if (el.scrollLeft > 0) {\n            system = 'reverse'; // scroll is a positive number from the right edge\n        }\n        else {\n            system = 'negative'; // scroll is a negative number from the right edge\n        }\n    }\n    removeElement(el);\n    return system;\n}\n\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n    constructor(scrollEl, isRtl) {\n        this.scrollEl = scrollEl;\n        this.isRtl = isRtl;\n        this.updateSize = () => {\n            let { scrollEl } = this;\n            let els = findElements(scrollEl, STICKY_SELECTOR);\n            let elGeoms = this.queryElGeoms(els);\n            let viewportWidth = scrollEl.clientWidth;\n            assignStickyPositions(els, elGeoms, viewportWidth);\n        };\n    }\n    queryElGeoms(els) {\n        let { scrollEl, isRtl } = this;\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n        let elGeoms = [];\n        for (let el of els) {\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n            -canvasOrigin.left, -canvasOrigin.top);\n            let elRect = el.getBoundingClientRect();\n            let computedStyles = window.getComputedStyle(el);\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n            let naturalBound = null;\n            if (textAlign === 'start') {\n                textAlign = isRtl ? 'right' : 'left';\n            }\n            else if (textAlign === 'end') {\n                textAlign = isRtl ? 'left' : 'right';\n            }\n            if (computedStyles.position !== 'sticky') {\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n            }\n            elGeoms.push({\n                parentBound,\n                naturalBound,\n                elWidth: elRect.width,\n                elHeight: elRect.height,\n                textAlign,\n            });\n        }\n        return elGeoms;\n    }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach((el, i) => {\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\n        let parentWidth = parentBound.right - parentBound.left;\n        let left;\n        if (textAlign === 'center' &&\n            parentWidth > viewportWidth) {\n            left = (viewportWidth - elWidth) / 2;\n        }\n        else { // if parent container can be completely in view, we don't need stickiness\n            left = '';\n        }\n        applyStyle(el, {\n            left,\n            right: left,\n            top: 0,\n        });\n    });\n}\n\nclass ClippedScroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.elRef = createRef();\n        this.state = {\n            xScrollbarWidth: 0,\n            yScrollbarWidth: 0,\n        };\n        this.handleScroller = (scroller) => {\n            this.scroller = scroller;\n            setRef(this.props.scrollerRef, scroller);\n        };\n        this.handleSizing = () => {\n            let { props } = this;\n            if (props.overflowY === 'scroll-hidden') {\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\n            }\n            if (props.overflowX === 'scroll-hidden') {\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n        let overcomeLeft = 0;\n        let overcomeRight = 0;\n        let overcomeBottom = 0;\n        let { overflowX, overflowY } = props;\n        if (props.forPrint) {\n            overflowX = 'visible';\n            overflowY = 'visible';\n        }\n        if (overflowX === 'scroll-hidden') {\n            overcomeBottom = state.xScrollbarWidth;\n        }\n        if (overflowY === 'scroll-hidden') {\n            if (state.yScrollbarWidth != null) {\n                if (isScrollbarOnLeft) {\n                    overcomeLeft = state.yScrollbarWidth;\n                }\n                else {\n                    overcomeRight = state.yScrollbarWidth;\n                }\n            }\n        }\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        if (this.props.forPrint && !prevProps.forPrint) {\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\n        }\n        return {};\n    }\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { props, scroller: { el: scrollerEl } } = this;\n        if (!isPropsEqual(prevProps, props)) { // an external change?\n            this.handleSizing();\n        }\n        if (snapshot.simulateScrollLeft !== undefined) {\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n        }\n        else if (!props.forPrint && prevProps.forPrint) {\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n            scrollerEl.style.left = '';\n            scrollerEl.scrollLeft = restoredScrollLeft;\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    needsXScrolling() {\n        return this.scroller.needsXScrolling();\n    }\n    needsYScrolling() {\n        return this.scroller.needsYScrolling();\n    }\n}\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n    constructor(el) {\n        this.el = el;\n        this.emitter = new Emitter();\n        this.isScrolling = false;\n        this.isTouching = false; // user currently has finger down?\n        this.isRecentlyWheeled = false;\n        this.isRecentlyScrolled = false;\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n        // Handlers\n        // ----------------------------------------------------------------------------------------------\n        this.handleScroll = () => {\n            this.startScroll();\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n            this.isRecentlyScrolled = true;\n            this.scrollWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleWheel = () => {\n            this.isRecentlyWheeled = true;\n            this.wheelWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleTouchStart = () => {\n            this.isTouching = true;\n        };\n        this.handleTouchEnd = () => {\n            this.isTouching = false;\n            // if the user ended their touch, and the scroll area wasn't moving,\n            // we consider this to be the end of the scroll.\n            if (!this.isRecentlyScrolled) {\n                this.endScroll(); // won't fire if already ended\n            }\n        };\n        el.addEventListener('scroll', this.handleScroll);\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.addEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.addEventListener(eventName, this.handleWheel);\n        }\n    }\n    destroy() {\n        let { el } = this;\n        el.removeEventListener('scroll', this.handleScroll);\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.removeEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.removeEventListener(eventName, this.handleWheel);\n        }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n    startScroll() {\n        if (!this.isScrolling) {\n            this.isScrolling = true;\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n        }\n    }\n    endScroll() {\n        if (this.isScrolling) {\n            this.emitter.trigger('scrollEnd');\n            this.isScrolling = false;\n            this.isRecentlyScrolled = true;\n            this.isRecentlyWheeled = false;\n            this.scrollWaiter.clear();\n            this.wheelWaiter.clear();\n        }\n    }\n    _handleScrollWaited() {\n        this.isRecentlyScrolled = false;\n        // only end the scroll if not currently touching.\n        // if touching, the scrolling will end later, on touchend.\n        if (!this.isTouching) {\n            this.endScroll(); // won't fire if already ended\n        }\n    }\n    _handleWheelWaited() {\n        this.isRecentlyWheeled = false;\n    }\n}\n\nclass ScrollSyncer {\n    constructor(isVertical, scrollEls) {\n        this.isVertical = isVertical;\n        this.scrollEls = scrollEls;\n        this.isPaused = false;\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\n    }\n    destroy() {\n        for (let scrollListener of this.scrollListeners) {\n            scrollListener.destroy();\n        }\n    }\n    bindScroller(el) {\n        let { scrollEls, isVertical } = this;\n        let scrollListener = new ScrollListener(el);\n        const onScroll = (isWheel, isTouch) => {\n            if (!this.isPaused) {\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n                    this.assignMaster(el);\n                }\n                if (this.masterEl === el) { // dealing with current\n                    for (let otherEl of scrollEls) {\n                        if (otherEl !== el) {\n                            if (isVertical) {\n                                otherEl.scrollTop = el.scrollTop;\n                            }\n                            else {\n                                otherEl.scrollLeft = el.scrollLeft;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const onScrollEnd = () => {\n            if (this.masterEl === el) {\n                this.masterEl = null;\n            }\n        };\n        scrollListener.emitter.on('scroll', onScroll);\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\n        return scrollListener;\n    }\n    assignMaster(el) {\n        this.masterEl = el;\n        for (let scrollListener of this.scrollListeners) {\n            if (scrollListener.el !== el) {\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n            }\n        }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n    forceScrollLeft(scrollLeft) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n        this.isPaused = false;\n    }\n    forceScrollTop(top) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            listener.el.scrollTop = top;\n        }\n        this.isPaused = false;\n    }\n}\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n        this.clippedScrollerRefs = new RefMap();\n        // doesn't hold non-scrolling els used just for padding\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n        this.scrollSyncersBySection = {};\n        this.scrollSyncersByColumn = {};\n        // for row-height-syncing\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n        this.rowInnerMaxHeightMap = new Map();\n        this.anyRowHeightsChanged = false;\n        this.recentSizingCnt = 0;\n        this.state = {\n            shrinkWidths: [],\n            forceYScrollbars: false,\n            forceXScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n            sectionRowMaxHeights: [],\n        };\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n            if (!this.allowSizing()) {\n                return;\n            }\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n                this.anyRowHeightsChanged = true;\n            }\n            let otherState = {};\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n            }\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\n                if (!this.rowUnstableMap.size) {\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n                }\n            });\n        };\n        this.handleRowHeightChange = (rowEl, isStable) => {\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\n            if (!isStable) {\n                rowUnstableMap.set(rowEl, true);\n            }\n            else {\n                rowUnstableMap.delete(rowEl);\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n                    this.anyRowHeightsChanged = true;\n                }\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n                    this.anyRowHeightsChanged = false;\n                    this.setState({\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n                    });\n                }\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { shrinkWidths } = state;\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        this.getDims();\n        // TODO: make DRY\n        let sectionConfigs = props.sections;\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n        const roleAttrs = { role: 'rowgroup' };\n        return createElement('table', {\n            ref: props.elRef,\n            role: 'grid',\n            className: classNames.join(' '),\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\n    }\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\n        }\n        let { state } = this;\n        let { scrollerClientWidths, scrollerClientHeights } = state;\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let index = sectionIndex * chunksPerSection + chunkIndex;\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let isVScrollSide = chunkIndex === sideScrollIndex;\n        let isLastSection = sectionIndex === sectionCnt - 1;\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth,\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n            expandRows,\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n            rowSyncHeights: rowHeights,\n            reportRowHeightChange: this.handleRowHeightChange,\n        }, isHeader);\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n            !allowXScrolling ? 'hidden' :\n                (isLastSection ? 'auto' : 'scroll-hidden');\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n            !allowYScrolling ? 'hidden' :\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\n        return createElement(isHeader ? 'th' : 'td', {\n            key: chunkConfig.key,\n            ref: this.chunkElRefs.createRef(index),\n            role: 'presentation',\n        }, content);\n    }\n    componentDidMount() {\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n        this.updateScrollSyncers();\n        this.handleSizing(false);\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        this.updateScrollSyncers();\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n        this.destroyScrollSyncers();\n    }\n    allowSizing() {\n        let now = new Date();\n        if (!this.lastSizingDate ||\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n            this.lastSizingDate = now;\n            this.recentSizingCnt = 0;\n            return true;\n        }\n        return (this.recentSizingCnt += 1) <= 10;\n    }\n    computeShrinkWidths() {\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let shrinkWidths = [];\n        colGroupStats.forEach((colGroupStat, i) => {\n            if (colGroupStat.hasShrinkCol) {\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\n            }\n        });\n        return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n    computeSectionRowMaxHeights() {\n        let newHeightMap = new Map();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sectionRowMaxHeights = [];\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let sectionConfig = this.props.sections[sectionI];\n            let assignableHeights = []; // chunk, row\n            if (sectionConfig && sectionConfig.syncRowHeights) {\n                let rowHeightsByChunk = [];\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                    let index = sectionI * chunksPerSection + chunkI;\n                    let rowHeights = [];\n                    let chunkEl = this.chunkElRefs.currentMap[index];\n                    if (chunkEl) {\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\n                            let max = getRowInnerMaxHeight(rowEl);\n                            newHeightMap.set(rowEl, max);\n                            return max;\n                        });\n                    }\n                    else {\n                        rowHeights = [];\n                    }\n                    rowHeightsByChunk.push(rowHeights);\n                }\n                let rowCnt = rowHeightsByChunk[0].length;\n                let isEqualRowCnt = true;\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n                        isEqualRowCnt = false;\n                        break;\n                    }\n                }\n                if (!isEqualRowCnt) {\n                    let chunkHeightSums = [];\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n                    }\n                    let maxTotalSum = Math.max(...chunkHeightSums);\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n                        // whatever is leftover goes to the first row\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n                        let rowInChunkHeights = [];\n                        let row = 0;\n                        if (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\n                            row += 1;\n                        }\n                        while (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\n                            row += 1;\n                        }\n                        assignableHeights.push(rowInChunkHeights);\n                    }\n                }\n                else {\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        assignableHeights.push([]);\n                    }\n                    for (let row = 0; row < rowCnt; row += 1) {\n                        let rowHeightsAcrossChunks = [];\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            let h = rowHeightsByChunk[chunkI][row];\n                            if (h != null) { // protect against outerContent\n                                rowHeightsAcrossChunks.push(h);\n                            }\n                        }\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            assignableHeights[chunkI].push(maxHeight);\n                        }\n                    }\n                }\n            }\n            sectionRowMaxHeights.push(assignableHeights);\n        }\n        this.rowInnerMaxHeightMap = newHeightMap;\n        return sectionRowMaxHeights;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let lastSectionI = sectionCnt - 1;\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\n        let scrollerEls = this.scrollerElRefs.currentMap;\n        let forceYScrollbars = false;\n        let forceXScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n            let index = sectionI * chunksPerSection + sideScrollI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n            let index = lastSectionI * chunksPerSection + chunkI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsXScrolling()) {\n                forceXScrollbars = true;\n                break;\n            }\n        }\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                let index = sectionI * chunksPerSection + chunkI;\n                let scrollerEl = scrollerEls[index];\n                if (scrollerEl) {\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    let harnessEl = scrollerEl.parentNode;\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                }\n            }\n        }\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n    updateStickyScrolling() {\n        let { isRtl } = this.context;\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\n        this.getStickyScrolling(argsByKey)\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\n    }\n    updateScrollSyncers() {\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let scrollElsBySection = {};\n        let scrollElsByColumn = {};\n        let scrollElMap = this.scrollerElRefs.currentMap;\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let startIndex = sectionI * chunksPerSection;\n            let endIndex = startIndex + chunksPerSection;\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n        }\n        for (let col = 0; col < chunksPerSection; col += 1) {\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n        }\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n    destroyScrollSyncers() {\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n    getChunkConfigByIndex(index) {\n        let chunksPerSection = this.getDims()[1];\n        let sectionI = Math.floor(index / chunksPerSection);\n        let chunkI = index % chunksPerSection;\n        let sectionConfig = this.props.sections[sectionI];\n        return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n    forceScrollLeft(col, scrollLeft) {\n        let scrollSyncer = this.scrollSyncersByColumn[col];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollLeft(scrollLeft);\n        }\n    }\n    forceScrollTop(sectionI, scrollTop) {\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollTop(scrollTop);\n        }\n    }\n    _handleChunkEl(chunkEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.elRef, chunkEl);\n        }\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        }\n    }\n    getDims() {\n        let sectionCnt = this.props.sections.length;\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n        return [sectionCnt, chunksPerSection];\n    }\n}\nScrollGrid.addStateEquality({\n    shrinkWidths: isArraysEqual,\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction sumNumbers(numbers) {\n    let sum = 0;\n    for (let n of numbers) {\n        sum += n;\n    }\n    return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n    if (innerHeights.length) {\n        return Math.max(...innerHeights);\n    }\n    return 0;\n}\nfunction getElHeight(el) {\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n    let children = colGroupStats.map((colGroupStat, i) => {\n        let width = colGroupStat.width;\n        if (width === 'shrink') {\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n        }\n        return ( // eslint-disable-next-line react/jsx-key\n        createElement(\"col\", { style: { width } }));\n    });\n    return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n    return {\n        hasShrinkCol,\n        totalColWidth,\n        totalColMinWidth,\n        allowXScrolling,\n        cols: colGroupConfig.cols,\n        width: colGroupConfig.width,\n    };\n}\nfunction sumColProp(cols, propName) {\n    let total = 0;\n    for (let col of cols) {\n        let val = col[propName];\n        if (typeof val === 'number') {\n            total += val * (col.span || 1);\n        }\n    }\n    return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n    cols: isColPropsEqual,\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n    return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n    scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n    return new StickyScrolling(scrollEl, isRtl);\n}\n\nexport { ScrollGrid };\n", "import { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim, injectStyles } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\n\nconst MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000;\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [\n    { years: 1 },\n    { months: 1 },\n    { days: 1 },\n    { hours: 1 },\n    { minutes: 30 },\n    { minutes: 15 },\n    { minutes: 10 },\n    { minutes: 5 },\n    { minutes: 1 },\n    { seconds: 30 },\n    { seconds: 15 },\n    { seconds: 10 },\n    { seconds: 5 },\n    { seconds: 1 },\n    { milliseconds: 500 },\n    { milliseconds: 100 },\n    { milliseconds: 10 },\n    { milliseconds: 1 },\n];\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n    let tDateProfile = {\n        labelInterval: allOptions.slotLabelInterval,\n        slotDuration: allOptions.slotDuration,\n    };\n    validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n    ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n    ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n    let input = allOptions.slotLabelFormat;\n    let rawFormats = Array.isArray(input) ? input :\n        (input != null) ? [input] :\n            computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n    tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));\n    tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n    let largeUnit = null;\n    if (!tDateProfile.isTimeScale) {\n        const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        if (/year|month|week/.test(slotUnit)) {\n            largeUnit = slotUnit;\n        }\n    }\n    tDateProfile.largeUnit = largeUnit;\n    tDateProfile.emphasizeWeeks =\n        asCleanDays(tDateProfile.slotDuration) === 1 &&\n            currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\n            !allOptions.businessHours;\n    /*\n    console.log('label interval =', timelineView.labelInterval.humanize())\n    console.log('slot duration =', timelineView.slotDuration.humanize())\n    console.log('header formats =', timelineView.headerFormats)\n    console.log('isTimeScale', timelineView.isTimeScale)\n    console.log('largeUnit', timelineView.largeUnit)\n    */\n    let rawSnapDuration = allOptions.snapDuration;\n    let snapDuration;\n    let snapsPerSlot;\n    if (rawSnapDuration) {\n        snapDuration = createDuration(rawSnapDuration);\n        snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\n        // ^ TODO: warning if not whole?\n    }\n    if (snapsPerSlot == null) {\n        snapDuration = tDateProfile.slotDuration;\n        snapsPerSlot = 1;\n    }\n    tDateProfile.snapDuration = snapDuration;\n    tDateProfile.snapsPerSlot = snapsPerSlot;\n    // more...\n    let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\n    // TODO: why not use normalizeRange!?\n    let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n    let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\n    // apply slotMinTime/slotMaxTime\n    // TODO: View should be responsible.\n    if (tDateProfile.isTimeScale) {\n        normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n        normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n    }\n    tDateProfile.timeWindowMs = timeWindowMs;\n    tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };\n    let slotDates = [];\n    let date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            slotDates.push(date);\n        }\n        date = dateEnv.add(date, tDateProfile.slotDuration);\n    }\n    tDateProfile.slotDates = slotDates;\n    // more...\n    let snapIndex = -1;\n    let snapDiff = 0; // index of the diff :(\n    const snapDiffToIndex = [];\n    const snapIndexToDiff = [];\n    date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            snapIndex += 1;\n            snapDiffToIndex.push(snapIndex);\n            snapIndexToDiff.push(snapDiff);\n        }\n        else {\n            snapDiffToIndex.push(snapIndex + 0.5);\n        }\n        date = dateEnv.add(date, tDateProfile.snapDuration);\n        snapDiff += 1;\n    }\n    tDateProfile.snapDiffToIndex = snapDiffToIndex;\n    tDateProfile.snapIndexToDiff = snapIndexToDiff;\n    tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n    tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\n    // more...\n    tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n    tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n    tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n    return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n    let normalDate = date;\n    if (!tDateProfile.isTimeScale) {\n        normalDate = startOfDay(normalDate);\n        if (tDateProfile.largeUnit) {\n            normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n        }\n    }\n    return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n    if (!tDateProfile.isTimeScale) {\n        range = computeVisibleDayRange(range);\n        if (tDateProfile.largeUnit) {\n            let dayRange = range; // preserve original result\n            range = {\n                start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n                end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\n            };\n            // if date is partially through the interval, or is in the same interval as the start,\n            // make the exclusive end be the *next* interval\n            if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n                range = {\n                    start: range.start,\n                    end: dateEnv.add(range.end, tDateProfile.slotDuration),\n                };\n            }\n        }\n    }\n    return range;\n}\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n    if (dateProfileGenerator.isHiddenDay(date)) {\n        return false;\n    }\n    if (tDateProfile.isTimeScale) {\n        // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n        let day = startOfDay(date);\n        let timeMs = date.valueOf() - day.valueOf();\n        let ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n        ms = ((ms % 86400000) + 86400000) % 86400000; // make negative values wrap to 24hr clock\n        return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n    }\n    return true;\n}\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    // make sure labelInterval doesn't exceed the max number of cells\n    if (tDateProfile.labelInterval) {\n        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n        if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotLabelInterval results in too many cells');\n            tDateProfile.labelInterval = null;\n        }\n    }\n    // make sure slotDuration doesn't exceed the maximum number of cells\n    if (tDateProfile.slotDuration) {\n        const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n        if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotDuration results in too many cells');\n            tDateProfile.slotDuration = null;\n        }\n    }\n    // make sure labelInterval is a multiple of slotDuration\n    if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n        const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n        if (slotsPerLabel === null || slotsPerLabel < 1) {\n            console.warn('slotLabelInterval must be a multiple of slotDuration');\n            tDateProfile.slotDuration = null;\n        }\n    }\n}\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { labelInterval } = tDateProfile;\n    if (!labelInterval) {\n        // compute based off the slot duration\n        // find the largest label interval with an acceptable slots-per-label\n        let input;\n        if (tDateProfile.slotDuration) {\n            for (input of STOCK_SUB_DURATIONS) {\n                const tryLabelInterval = createDuration(input);\n                const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n                if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                    labelInterval = tryLabelInterval;\n                    break;\n                }\n            }\n            // use the slot duration as a last resort\n            if (!labelInterval) {\n                labelInterval = tDateProfile.slotDuration;\n            }\n            // compute based off the view's duration\n            // find the largest label interval that yields the minimum number of labels\n        }\n        else {\n            for (input of STOCK_SUB_DURATIONS) {\n                labelInterval = createDuration(input);\n                const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n                if (labelCnt >= MIN_AUTO_LABELS) {\n                    break;\n                }\n            }\n        }\n        tDateProfile.labelInterval = labelInterval;\n    }\n    return labelInterval;\n}\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { slotDuration } = tDateProfile;\n    if (!slotDuration) {\n        const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n        // compute based off the label interval\n        // find the largest slot duration that is different from labelInterval, but still acceptable\n        for (let input of STOCK_SUB_DURATIONS) {\n            const trySlotDuration = createDuration(input);\n            const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                slotDuration = trySlotDuration;\n                break;\n            }\n        }\n        // only allow the value if it won't exceed the view's # of slots limit\n        if (slotDuration) {\n            const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n            if (slotCnt > MAX_AUTO_CELLS) {\n                slotDuration = null;\n            }\n        }\n        // use the label interval as a last resort\n        if (!slotDuration) {\n            slotDuration = labelInterval;\n        }\n        tDateProfile.slotDuration = slotDuration;\n    }\n    return slotDuration;\n}\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n    let format1;\n    let format2;\n    const { labelInterval } = tDateProfile;\n    let unit = greatestDurationDenominator(labelInterval).unit;\n    const weekNumbersVisible = allOptions.weekNumbers;\n    let format0 = (format1 = (format2 = null));\n    // NOTE: weekNumber computation function wont work\n    if ((unit === 'week') && !weekNumbersVisible) {\n        unit = 'day';\n    }\n    switch (unit) {\n        case 'year':\n            format0 = { year: 'numeric' }; // '2015'\n            break;\n        case 'month':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { month: 'short' }; // 'Jan'\n            break;\n        case 'week':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { week: 'narrow' }; // 'Wk4'\n            break;\n        case 'day':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric', month: 'long' }; // 'January 2014'\n            }\n            else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n                format0 = { month: 'long' }; // 'January'\n            }\n            if (weekNumbersVisible) {\n                format1 = { week: 'short' }; // 'Wk 4'\n            }\n            format2 = { weekday: 'narrow', day: 'numeric' }; // 'Su 9'\n            break;\n        case 'hour':\n            if (weekNumbersVisible) {\n                format0 = { week: 'short' }; // 'Wk 4'\n            }\n            if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n                format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true }; // Sat 4/7\n            }\n            format2 = {\n                hour: 'numeric',\n                minute: '2-digit',\n                omitZeroMinute: true,\n                meridiem: 'short',\n            };\n            break;\n        case 'minute':\n            // sufficiently large number of different minute cells?\n            if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = {\n                    hour: 'numeric',\n                    meridiem: 'short',\n                };\n                format1 = (params) => (':' + padStart(params.date.minute, 2) // ':30'\n                );\n            }\n            else {\n                format0 = {\n                    hour: 'numeric',\n                    minute: 'numeric',\n                    meridiem: 'short',\n                };\n            }\n            break;\n        case 'second':\n            // sufficiently large number of different second cells?\n            if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' }; // '8:30 PM'\n                format1 = (params) => (':' + padStart(params.date.second, 2) // ':30'\n                );\n            }\n            else {\n                format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            }\n            break;\n        case 'millisecond':\n            format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            format1 = (params) => ('.' + padStart(params.millisecond, 3));\n            break;\n    }\n    return [].concat(format0 || [], format1 || [], format2 || []);\n}\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n    let range = dateProfile.currentRange;\n    let res = null;\n    if (unit === 'years') {\n        res = dateEnv.diffWholeYears(range.start, range.end);\n    }\n    else if (unit === 'months') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'weeks') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'days') {\n        res = diffWholeDays(range.start, range.end);\n    }\n    return res || 0;\n}\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n    let { slotDates, emphasizeWeeks } = tDateProfile;\n    let prevWeekNumber = null;\n    let isWeekStarts = [];\n    for (let slotDate of slotDates) {\n        let weekNumber = dateEnv.computeWeekNumber(slotDate);\n        let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber);\n        prevWeekNumber = weekNumber;\n        isWeekStarts.push(isWeekStart);\n    }\n    return isWeekStarts;\n}\nfunction buildCellRows(tDateProfile, dateEnv) {\n    let slotDates = tDateProfile.slotDates;\n    let formats = tDateProfile.headerFormats;\n    let cellRows = formats.map(() => []); // indexed by row,col\n    let slotAsDays = asCleanDays(tDateProfile.slotDuration);\n    let guessedSlotUnit = slotAsDays === 7 ? 'week' :\n        slotAsDays === 1 ? 'day' :\n            null;\n    // specifically for navclicks\n    let rowUnitsFromFormats = formats.map((format) => (format.getLargestUnit ? format.getLargestUnit() : null));\n    // builds cellRows and slotCells\n    for (let i = 0; i < slotDates.length; i += 1) {\n        let date = slotDates[i];\n        let isWeekStart = tDateProfile.isWeekStarts[i];\n        for (let row = 0; row < formats.length; row += 1) {\n            let format = formats[row];\n            let rowCells = cellRows[row];\n            let leadingCell = rowCells[rowCells.length - 1];\n            let isLastRow = row === formats.length - 1;\n            let isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n            let newCell = null;\n            let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n            if (isSuperRow) {\n                let text = dateEnv.format(date, format);\n                if (!leadingCell || (leadingCell.text !== text)) {\n                    newCell = buildCellObject(date, text, rowUnit);\n                }\n                else {\n                    leadingCell.colspan += 1;\n                }\n            }\n            else if (!leadingCell ||\n                isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n                let text = dateEnv.format(date, format);\n                newCell = buildCellObject(date, text, rowUnit);\n            }\n            else {\n                leadingCell.colspan += 1;\n            }\n            if (newCell) {\n                newCell.weekStart = isWeekStart;\n                rowCells.push(newCell);\n            }\n        }\n    }\n    return cellRows;\n}\nfunction buildCellObject(date, text, rowUnit) {\n    return { date, text, rowUnit, colspan: 1, isWeekStart: false };\n}\n\nclass TimelineHeaderTh extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n        this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    }\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options } = context;\n        let { cell, dateProfile, tDateProfile } = props;\n        // the cell.rowUnit is f'd\n        // giving 'month' for a 3-day view\n        // workaround: to infer day, do NOT time\n        let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n        let renderProps = this.refineRenderProps({\n            level: props.rowLevel,\n            dateMarker: cell.date,\n            text: cell.text,\n            dateEnv: context.dateEnv,\n            viewApi: context.viewApi,\n        });\n        return (createElement(ContentContainer, { elTag: \"th\", elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-label',\n                cell.isWeekStart && 'fc-timeline-slot-em',\n                ...( // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n                cell.rowUnit === 'time' ?\n                    getSlotClassNames(dateMeta, context.theme) :\n                    getDayClassNames(dateMeta, context.theme)),\n            ], elAttrs: {\n                colSpan: cell.colspan,\n                'data-date': dateEnv.formatIso(cell.date, {\n                    omitTime: !tDateProfile.isTimeScale,\n                    omitTimeZoneOffset: true,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (createElement(\"div\", { className: \"fc-timeline-slot-frame\", style: { height: props.rowInnerHeight } },\n            createElement(InnerContent, { elTag: \"a\", elClasses: [\n                    'fc-timeline-slot-cushion',\n                    'fc-scrollgrid-sync-inner',\n                    props.isSticky && 'fc-sticky',\n                ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })))));\n    }\n}\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n    return (rowUnit && rowUnit !== 'time')\n        ? buildNavLinkAttrs(context, cellDate, rowUnit)\n        : {};\n}\nfunction renderInnerContent(renderProps) {\n    return renderProps.text;\n}\nfunction refineRenderProps(input) {\n    return {\n        level: input.level,\n        date: input.dateEnv.toDate(input.dateMarker),\n        view: input.viewApi,\n        text: input.text,\n    };\n}\n\nclass TimelineHeaderRows extends BaseComponent {\n    render() {\n        let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;\n        let { cellRows } = tDateProfile;\n        return (createElement(Fragment, null, cellRows.map((rowCells, rowLevel) => {\n            let isLast = rowLevel === cellRows.length - 1;\n            let isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n            let classNames = [\n                'fc-timeline-header-row',\n                isChrono ? 'fc-timeline-header-row-chrono' : '',\n            ];\n            return ( // eslint-disable-next-line react/no-array-index-key\n            createElement(\"tr\", { key: rowLevel, className: classNames.join(' ') }, rowCells.map((cell) => (createElement(TimelineHeaderTh, { key: cell.date.toISOString(), cell: cell, rowLevel: rowLevel, dateProfile: dateProfile, tDateProfile: tDateProfile, todayRange: todayRange, nowDate: nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))));\n        })));\n    }\n}\n\nclass TimelineCoords {\n    constructor(slatRootEl, // okay to expose?\n    slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n        this.slatRootEl = slatRootEl;\n        this.dateProfile = dateProfile;\n        this.tDateProfile = tDateProfile;\n        this.dateEnv = dateEnv;\n        this.isRtl = isRtl;\n        this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\n        false);\n        // for the inner divs within the slats\n        // used for event rendering and scrollTime, to disregard slat border\n        this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\n        false);\n    }\n    isDateInRange(date) {\n        return rangeContainsMarker(this.dateProfile.currentRange, date);\n    }\n    // results range from negative width of area to 0\n    dateToCoord(date) {\n        let { tDateProfile } = this;\n        let snapCoverage = this.computeDateSnapCoverage(date);\n        let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n        let slotIndex = Math.floor(slotCoverage);\n        slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n        let partial = slotCoverage - slotIndex;\n        let { innerCoordCache, outerCoordCache } = this;\n        if (this.isRtl) {\n            return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] -\n                (innerCoordCache.getWidth(slotIndex) * partial));\n        }\n        return (outerCoordCache.lefts[slotIndex] +\n            (innerCoordCache.getWidth(slotIndex) * partial));\n    }\n    rangeToCoords(range) {\n        return {\n            start: this.dateToCoord(range.start),\n            end: this.dateToCoord(range.end),\n        };\n    }\n    durationToCoord(duration) {\n        let { dateProfile, tDateProfile, dateEnv, isRtl } = this;\n        let coord = 0;\n        if (dateProfile) {\n            let date = dateEnv.add(dateProfile.activeRange.start, duration);\n            if (!tDateProfile.isTimeScale) {\n                date = startOfDay(date);\n            }\n            coord = this.dateToCoord(date);\n            // hack to overcome the left borders of non-first slat\n            if (!isRtl && coord) {\n                coord += 1;\n            }\n        }\n        return coord;\n    }\n    coordFromLeft(coord) {\n        if (this.isRtl) {\n            return this.outerCoordCache.originClientRect.width - coord;\n        }\n        return coord;\n    }\n    // returned value is between 0 and the number of snaps\n    computeDateSnapCoverage(date) {\n        return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n    }\n}\n// returned value is between 0 and the number of snaps\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n    let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n    if (snapDiff < 0) {\n        return 0;\n    }\n    if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n        return tDateProfile.snapCnt;\n    }\n    let snapDiffInt = Math.floor(snapDiff);\n    let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n    if (isInt(snapCoverage)) { // not an in-between value\n        snapCoverage += snapDiff - snapDiffInt; // add the remainder\n    }\n    else {\n        // a fractional value, meaning the date is not visible\n        // always round up in this case. works for start AND end dates in a range.\n        snapCoverage = Math.ceil(snapCoverage);\n    }\n    return snapCoverage;\n}\nfunction coordToCss(hcoord, isRtl) {\n    if (hcoord === null) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoord, left: '' };\n    }\n    return { left: hcoord, right: '' };\n}\nfunction coordsToCss(hcoords, isRtl) {\n    if (!hcoords) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoords.start, left: -hcoords.end };\n    }\n    return { left: hcoords.start, right: -hcoords.end };\n}\n\nclass TimelineHeader extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n    }\n    render() {\n        let { props, context } = this;\n        // TODO: very repetitive\n        // TODO: make part of tDateProfile?\n        let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\n        // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n        let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n        return (createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(\"div\", { className: \"fc-timeline-header\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: \"fc-scrollgrid-sync-table\", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },\n                props.tableColGroupNode,\n                createElement(\"tbody\", null,\n                    createElement(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, rowInnerHeights: props.rowInnerHeights }))),\n            context.options.nowIndicator && (\n            // need to have a container regardless of whether the current view has a visible now indicator\n            // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n            // this issue doesn't happen for the timeline body however (\n            createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" }, (slatCoords && slatCoords.isDateInRange(nowDate)) && (createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-arrow'], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))))))));\n    }\n    componentDidMount() {\n        this.updateSize();\n    }\n    componentDidUpdate() {\n        this.updateSize();\n    }\n    updateSize() {\n        if (this.props.onMaxCushionWidth) {\n            this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n        }\n    }\n    computeMaxCushionWidth() {\n        return Math.max(...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map((el) => el.getBoundingClientRect().width));\n    }\n}\n\nclass TimelineSlatCell extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options, theme } = context;\n        let { date, tDateProfile, isEm } = props;\n        let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n        let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });\n        return (createElement(ContentContainer, { elTag: \"td\", elRef: props.elRef, elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-lane',\n                isEm && 'fc-timeline-slot-em',\n                tDateProfile.isTimeScale ? (isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ?\n                    'fc-timeline-slot-major' :\n                    'fc-timeline-slot-minor') : '',\n                ...(props.isDay ?\n                    getDayClassNames(dateMeta, theme) :\n                    getSlotClassNames(dateMeta, theme)),\n            ], elAttrs: {\n                'data-date': dateEnv.formatIso(date, {\n                    omitTimeZoneOffset: true,\n                    omitTime: !tDateProfile.isTimeScale,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLaneContent\", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\" }))));\n    }\n}\n\nclass TimelineSlatsBody extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { tDateProfile, cellElRefs } = props;\n        let { slotDates, isWeekStarts } = tDateProfile;\n        let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n        return (createElement(\"tbody\", null,\n            createElement(\"tr\", null, slotDates.map((slotDate, i) => {\n                let key = slotDate.toISOString();\n                return (createElement(TimelineSlatCell, { key: key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile: tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay: isDay }));\n            }))));\n    }\n}\n\nclass TimelineSlats extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n        this.cellElRefs = new RefMap();\n        this.handleScrollRequest = (request) => {\n            let { onScrollLeftRequest } = this.props;\n            let { coords } = this;\n            if (onScrollLeftRequest && coords) {\n                if (request.time) {\n                    let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n                    onScrollLeftRequest(scrollLeft);\n                }\n                return true;\n            }\n            return null; // best?\n        };\n    }\n    render() {\n        let { props, context } = this;\n        return (createElement(\"div\", { className: \"fc-timeline-slots\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                } },\n                props.tableColGroupNode,\n                createElement(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange }))));\n    }\n    componentDidMount() {\n        this.updateSizing();\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.updateSizing();\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { props, context } = this;\n        if (props.clientWidth !== null && // is sizing stable?\n            this.scrollResponder\n        // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetWidth) { // not hidden by css\n                this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n                if (props.onCoords) {\n                    props.onCoords(this.coords);\n                }\n                this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n            }\n        }\n    }\n    positionToHit(leftPosition) {\n        let { outerCoordCache } = this.coords;\n        let { dateEnv, isRtl } = this.context;\n        let { tDateProfile } = this.props;\n        let slatIndex = outerCoordCache.leftToIndex(leftPosition);\n        if (slatIndex != null) {\n            // somewhat similar to what TimeGrid does. consolidate?\n            let slatWidth = outerCoordCache.getWidth(slatIndex);\n            let partial = isRtl ?\n                (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\n                (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n            let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n            let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n            let end = dateEnv.add(start, tDateProfile.snapDuration);\n            return {\n                dateSpan: {\n                    range: { start, end },\n                    allDay: !this.props.tDateProfile.isTimeScale,\n                },\n                dayEl: this.cellElRefs.currentMap[slatIndex],\n                left: outerCoordCache.lefts[slatIndex],\n                right: outerCoordCache.rights[slatIndex],\n            };\n        }\n        return null;\n    }\n}\nfunction collectCellEls(elMap, slotDates) {\n    return slotDates.map((slotDate) => {\n        let key = slotDate.toISOString();\n        return elMap[key];\n    });\n}\n\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n    let hcoords = [];\n    if (timelineCoords) {\n        for (let seg of segs) {\n            let res = timelineCoords.rangeToCoords(seg);\n            let start = Math.round(res.start); // for barely-overlapping collisions\n            let end = Math.round(res.end); //\n            if (end - start < minWidth) {\n                end = start + minWidth;\n            }\n            hcoords.push({ start, end });\n        }\n    }\n    return hcoords;\n}\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\neventInstanceHeights, // might not have for every seg\nmoreLinkHeights, // might not have for every more-link\nstrictOrder, maxStackCnt) {\n    let segInputs = [];\n    let crudePlacements = []; // when we don't know dims\n    for (let i = 0; i < segs.length; i += 1) {\n        let seg = segs[i];\n        let instanceId = seg.eventRange.instance.instanceId;\n        let height = eventInstanceHeights[instanceId];\n        let hcoords = segHCoords[i];\n        if (height && hcoords) {\n            segInputs.push({\n                index: i,\n                span: hcoords,\n                thickness: height,\n            });\n        }\n        else {\n            crudePlacements.push({\n                seg,\n                hcoords,\n                top: null,\n            });\n        }\n    }\n    let hierarchy = new SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenPlacements = hiddenEntries.map((entry) => ({\n        seg: segs[entry.index],\n        hcoords: entry.span,\n        top: null,\n    }));\n    let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n    let moreLinkInputs = [];\n    let moreLinkCrudePlacements = [];\n    const extractSeg = (entry) => segs[entry.index];\n    for (let i = 0; i < hiddenGroups.length; i += 1) {\n        let hiddenGroup = hiddenGroups[i];\n        let sortedSegs = hiddenGroup.entries.map(extractSeg);\n        let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n        if (height != null) {\n            // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n            moreLinkInputs.push({\n                index: segs.length + i,\n                thickness: height,\n                span: hiddenGroup.span,\n            });\n        }\n        else {\n            moreLinkCrudePlacements.push({\n                seg: sortedSegs,\n                hcoords: hiddenGroup.span,\n                top: null,\n            });\n        }\n    }\n    // add more-links into the hierarchy, but don't limit\n    hierarchy.maxStackCnt = -1;\n    hierarchy.addSegs(moreLinkInputs);\n    let visibleRects = hierarchy.toRects();\n    let visiblePlacements = [];\n    let maxHeight = 0;\n    for (let rect of visibleRects) {\n        let segIndex = rect.index;\n        visiblePlacements.push({\n            seg: segIndex < segs.length\n                ? segs[segIndex] // a real seg\n                : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n            hcoords: rect.span,\n            top: rect.levelCoord,\n        });\n        maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n    }\n    return [\n        visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\n        maxHeight,\n    ];\n}\n\nclass TimelineLaneBg extends BaseComponent {\n    render() {\n        let { props } = this;\n        let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n        return props.timelineCoords && (createElement(\"div\", { className: \"fc-timeline-bg\" },\n            this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'),\n            this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'),\n            this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')));\n    }\n    renderSegs(segs, timelineCoords, fillType) {\n        let { todayRange, nowDate } = this.props;\n        let { isRtl } = this.context;\n        let segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n        let children = segs.map((seg, i) => {\n            let hcoords = segHCoords[i];\n            let hStyle = coordsToCss(hcoords, isRtl);\n            return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timeline-bg-harness\", style: hStyle }, fillType === 'bg-event' ?\n                createElement(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, todayRange, nowDate))) :\n                renderFill(fillType)));\n        });\n        return createElement(Fragment, null, children);\n    }\n}\n\nclass TimelineLaneSlicer extends Slicer {\n    sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n        let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n        let segs = [];\n        // protect against when the span is entirely in an invalid date region\n        if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\n            < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n            // intersect the footprint's range with the grid's range\n            let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n            if (slicedRange) {\n                segs.push({\n                    start: slicedRange.start,\n                    end: slicedRange.end,\n                    isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\n                        && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n                    isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\n                        && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\n                });\n            }\n        }\n        return segs;\n    }\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'narrow',\n});\nclass TimelineEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        return (createElement(StandardEvent, Object.assign({}, props, { elClasses: ['fc-timeline-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale })));\n    }\n}\n\nclass TimelineLaneMoreLink extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { hiddenSegs, placement, resourceId } = props;\n        let { top, hcoords } = placement;\n        let isVisible = hcoords && top !== null;\n        let hStyle = coordsToCss(hcoords, context.isRtl);\n        let extraDateSpan = resourceId ? { resourceId } : {};\n        return (createElement(MoreLinkContainer, { elRef: props.elRef, elClasses: ['fc-timeline-more-link'], elStyle: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs: hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: extraDateSpan, popoverContent: () => (createElement(Fragment, null, hiddenSegs.map((seg) => {\n                let instanceId = seg.eventRange.instance.instanceId;\n                return (createElement(\"div\", { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? 'hidden' : '' } },\n                    createElement(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n            }))) }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timeline-more-link-inner', 'fc-sticky'] }))));\n    }\n}\n\nclass TimelineLane extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.slicer = new TimelineLaneSlicer();\n        this.sortEventSegs = memoize(sortEventSegs);\n        this.harnessElRefs = new RefMap();\n        this.moreElRefs = new RefMap();\n        this.innerElRef = createRef();\n        // TODO: memoize event positioning\n        this.state = {\n            eventInstanceHeights: {},\n            moreLinkHeights: {},\n        };\n        this.handleResize = (isForced) => {\n            if (isForced) {\n                this.updateSize();\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\n        dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n        let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.segs : null) ||\n            [];\n        let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n        let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n        let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);\n        let isForcedInvisible = // TODO: more convenient\n         (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\n            {};\n        return (createElement(Fragment, null,\n            createElement(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */, dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),\n            createElement(\"div\", { className: \"fc-timeline-events fc-scrollgrid-sync-inner\", ref: this.innerElRef, style: { height: fgHeight } },\n                this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),\n                this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false))));\n    }\n    componentDidMount() {\n        this.updateSize();\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\n            prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n            prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n        ) {\n            this.updateSize();\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateSize() {\n        let { props } = this;\n        let { timelineCoords } = props;\n        const innerEl = this.innerElRef.current;\n        if (props.onHeightChange) {\n            props.onHeightChange(innerEl, false);\n        }\n        if (timelineCoords) {\n            this.setState({\n                eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (Math.round(harnessEl.getBoundingClientRect().height))),\n                moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (Math.round(moreEl.getBoundingClientRect().height))),\n            }, () => {\n                if (props.onHeightChange) {\n                    props.onHeightChange(innerEl, true);\n                }\n            });\n        }\n        // hack\n        if (props.syncParentMinHeight) {\n            innerEl.parentElement.style.minHeight = innerEl.style.height;\n        }\n    }\n    renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { harnessElRefs, moreElRefs, props, context } = this;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        return (createElement(Fragment, null, segPlacements.map((segPlacement) => {\n            let { seg, hcoords, top } = segPlacement;\n            if (Array.isArray(seg)) { // a more-link\n                let isoStr = buildIsoString(computeEarliestSegStart(seg));\n                return (createElement(TimelineLaneMoreLink, { key: 'm:' + isoStr /* \"m\" for \"more\" */, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible: isForcedInvisible }));\n            }\n            let instanceId = seg.eventRange.instance.instanceId;\n            let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n            let hStyle = coordsToCss(hcoords, context.isRtl);\n            return (createElement(\"div\", { key: 'e:' + instanceId /* \"e\" for \"event\" */, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: \"fc-timeline-event-harness\", style: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle) },\n                createElement(TimelineEvent, Object.assign({ isTimeScale: props.tDateProfile.isTimeScale, seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */ }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n        })));\n    }\n}\nTimelineLane.addStateEquality({\n    eventInstanceHeights: isPropsEqual,\n    moreLinkHeights: isPropsEqual,\n});\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n    if (!mirrorSegs.length || !timelineCoords) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg) => ({\n        seg,\n        hcoords: timelineCoords.rangeToCoords(seg),\n        top: topsByInstanceId[seg.eventRange.instance.instanceId],\n    }));\n}\nfunction buildAbsoluteTopHash(placements) {\n    let topsByInstanceId = {};\n    for (let placement of placements) {\n        let { seg } = placement;\n        if (!Array.isArray(seg)) { // doesn't represent a more-link\n            topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n        }\n    }\n    return topsByInstanceId;\n}\n\nclass TimelineGrid extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.slatsRef = createRef();\n        this.state = {\n            coords: null,\n        };\n        this.handeEl = (el) => {\n            if (el) {\n                this.context.registerInteractiveComponent(this, { el });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleCoords = (coords) => {\n            this.setState({ coords });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(coords);\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        return (createElement(\"div\", { className: \"fc-timeline-body\", ref: this.handeEl, style: {\n                minWidth: props.tableMinWidth,\n                height: props.clientHeight,\n                width: props.clientWidth,\n            } },\n            createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(Fragment, null,\n                createElement(TimelineSlats, { ref: this.slatsRef, dateProfile: dateProfile, tDateProfile: tDateProfile, nowDate: nowDate, todayRange: todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),\n                createElement(TimelineLane, { dateProfile: dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),\n                (options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" },\n                    createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-line'], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate }))))))));\n    }\n    // Hit System\n    // ------------------------------------------------------------------------------------------\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let slats = this.slatsRef.current;\n        let slatHit = slats.positionToHit(positionLeft);\n        if (slatHit) {\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: slatHit.dateSpan,\n                rect: {\n                    left: slatHit.left,\n                    right: slatHit.right,\n                    top: 0,\n                    bottom: elHeight,\n                },\n                dayEl: slatHit.dayEl,\n                layer: 0,\n            };\n        }\n        return null;\n    }\n}\n\nclass TimelineView extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n        this.scrollGridRef = createRef();\n        this.state = {\n            slatCoords: null,\n            slotCushionMaxWidth: null,\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n        };\n        this.handleScrollLeftRequest = (scrollLeft) => {\n            let scrollGrid = this.scrollGridRef.current;\n            scrollGrid.forceScrollLeft(0, scrollLeft);\n        };\n        this.handleMaxCushionWidth = (slotCushionMaxWidth) => {\n            this.setState({\n                slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\n            });\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n        let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n        let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n        let { slotMinWidth } = options;\n        let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n        let sections = [\n            {\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })),\n                    }],\n            },\n            {\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))),\n                    }],\n            },\n        ];\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: 'footer',\n                key: 'footer',\n                isSticky: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: renderScrollShim,\n                    }],\n            });\n        }\n        return (createElement(ViewContainer, { elClasses: [\n                'fc-timeline',\n                options.eventOverlap === false ?\n                    'fc-timeline-overlap-disabled' :\n                    '',\n            ], viewSpec: context.viewSpec },\n            createElement(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [\n                    { cols: slatCols },\n                ], sections: sections })));\n    }\n    computeFallbackSlotMinWidth(tDateProfile) {\n        return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel));\n    }\n}\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n    return [{\n            span: tDateProfile.slotCnt,\n            minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\n        }];\n}\n\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\ninjectStyles(css_248z);\n\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };\n", "import { createPlugin } from '@fullcalendar/core/index.js';\nimport premiumCommonPlugin from '@fullcalendar/premium-common/index.js';\nimport { TimelineView } from './internal.js';\nimport '@fullcalendar/core/internal.js';\nimport '@fullcalendar/core/preact.js';\nimport '@fullcalendar/scrollgrid/internal.js';\n\nvar index = createPlugin({\n    name: '@fullcalendar/timeline',\n    premiumReleaseDate: '2024-07-12',\n    deps: [premiumCommonPlugin],\n    initialView: 'timelineDay',\n    views: {\n        timeline: {\n            component: TimelineView,\n            usesMinMaxTime: true,\n            eventResizableFromStart: true, // how is this consumed for TimelineView tho?\n        },\n        timelineDay: {\n            type: 'timeline',\n            duration: { days: 1 },\n        },\n        timelineWeek: {\n            type: 'timeline',\n            duration: { weeks: 1 },\n        },\n        timelineMonth: {\n            type: 'timeline',\n            duration: { months: 1 },\n        },\n        timelineYear: {\n            type: 'timeline',\n            duration: { years: 1 },\n        },\n    },\n});\n\nexport { index as default };\n"],
  "mappings": "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",
  "names": ["scrollEl", "index", "isValidDate", "index"]
}
