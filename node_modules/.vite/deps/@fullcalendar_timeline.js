import "./chunk-T7UM46HU.js";
import {
  BaseComponent,
  BgEvent,
  ContentContainer,
  DateComponent,
  DelayedRunner,
  Emitter,
  MoreLinkContainer,
  NowIndicatorContainer,
  NowTimer,
  PositionCache,
  RefMap,
  Scroller,
  SegHierarchy,
  Slicer,
  StandardEvent,
  ViewContainer,
  _,
  addDays,
  addMs,
  applyStyle,
  asCleanDays,
  asRoughMinutes,
  asRoughMs,
  asRoughSeconds,
  buildEventRangeKey,
  buildIsoString,
  buildNavLinkAttrs,
  collectFromHash,
  compareObjs,
  computeEarliestSegStart,
  computeEdges,
  computeInnerRect,
  computeShrinkWidth,
  computeVisibleDayRange,
  config,
  createDuration,
  createFormatter,
  createPlugin,
  d,
  diffWholeDays,
  findDirectChildren,
  findElements,
  getAllowYScrolling,
  getCanVGrowWithinCell,
  getDateMeta,
  getDayClassNames,
  getIsRtlScrollbarOnLeft,
  getScrollGridClassNames,
  getScrollbarWidths,
  getSectionClassNames,
  getSectionHasLiquidHeight,
  getSegMeta,
  getSlotClassNames,
  getStickyFooterScrollbar,
  getStickyHeaderDates,
  greatestDurationDenominator,
  groupIntersectingEntries,
  hasShrinkWidth,
  injectStyles,
  intersectRanges,
  isArraysEqual,
  isColPropsEqual,
  isInt,
  isPropsEqual,
  isValidDate,
  mapHash,
  memoize,
  memoizeArraylike,
  memoizeHashlike,
  memoizeObjArg,
  multiplyDuration,
  padStart,
  rangeContainsMarker,
  removeElement,
  renderChunkContent,
  renderFill,
  renderMicroColGroup,
  renderScrollShim,
  sanitizeShrinkWidth,
  setRef,
  sortEventSegs,
  startOfDay,
  translateRect,
  wholeDivideDurations,
  y
} from "./chunk-LO7HI52N.js";
import "./chunk-OL46QLBJ.js";

// node_modules/@fullcalendar/premium-common/index.js
var UPGRADE_WINDOW = 365 + 7;
var INVALID_LICENSE_URL = "https://fullcalendar.io/docs/schedulerLicenseKey#invalid";
var OUTDATED_LICENSE_URL = "https://fullcalendar.io/docs/schedulerLicenseKey#outdated";
var PRESET_LICENSE_KEYS = [
  "GPL-My-Project-Is-Open-Source",
  "CC-Attribution-NonCommercial-NoDerivatives"
];
var CSS = {
  position: "absolute",
  zIndex: 99999,
  bottom: "1px",
  left: "1px",
  background: "#eee",
  borderColor: "#ddd",
  borderStyle: "solid",
  borderWidth: "1px 1px 0 0",
  padding: "2px 4px",
  fontSize: "12px",
  borderTopRightRadius: "3px"
};
function buildLicenseWarning(context) {
  let key = context.options.schedulerLicenseKey;
  let currentUrl = typeof window !== "undefined" ? window.location.href : "";
  if (!isImmuneUrl(currentUrl)) {
    let status = processLicenseKey(key, context.pluginHooks.premiumReleaseDate);
    if (status !== "valid") {
      return y("div", { className: "fc-license-message", style: CSS }, status === "outdated" ? y(
        _,
        null,
        "Your license key is too old to work with this version. ",
        y("a", { href: OUTDATED_LICENSE_URL }, "More Info")
      ) : y(
        _,
        null,
        "Your license key is invalid. ",
        y("a", { href: INVALID_LICENSE_URL }, "More Info")
      ));
    }
  }
  return null;
}
function processLicenseKey(key, premiumReleaseDate) {
  if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {
    return "valid";
  }
  const parts = (key || "").match(/^(\d+)-fcs-(\d+)$/);
  if (parts && parts[1].length === 10) {
    const purchaseDate = new Date(parseInt(parts[2], 10) * 1e3);
    const releaseDate = config.mockSchedulerReleaseDate || premiumReleaseDate;
    if (isValidDate(releaseDate)) {
      const minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);
      if (minPurchaseDate < purchaseDate) {
        return "valid";
      }
      return "outdated";
    }
  }
  return "invalid";
}
function isImmuneUrl(url) {
  return /\w+:\/\/fullcalendar\.io\/|\/examples\/[\w-]+\.html$/.test(url);
}
var OPTION_REFINERS = {
  schedulerLicenseKey: String
};
var index = createPlugin({
  name: "@fullcalendar/premium-common",
  premiumReleaseDate: "2024-07-12",
  optionRefiners: OPTION_REFINERS,
  viewContainerAppends: [buildLicenseWarning]
});

// node_modules/@fullcalendar/scrollgrid/internal.js
function getScrollCanvasOrigin(scrollEl) {
  let rect = scrollEl.getBoundingClientRect();
  let edges = computeEdges(scrollEl);
  return {
    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),
    top: rect.top + edges.borderTop - scrollEl.scrollTop
  };
}
function getScrollFromLeftEdge(el) {
  let scrollLeft = el.scrollLeft;
  let computedStyles = window.getComputedStyle(el);
  if (computedStyles.direction === "rtl") {
    switch (getRtlScrollSystem()) {
      case "negative":
        scrollLeft *= -1;
      case "reverse":
        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;
    }
  }
  return scrollLeft;
}
function setScrollFromLeftEdge(el, scrollLeft) {
  let computedStyles = window.getComputedStyle(el);
  if (computedStyles.direction === "rtl") {
    switch (getRtlScrollSystem()) {
      case "reverse":
        scrollLeft = el.scrollWidth - scrollLeft;
        break;
      case "negative":
        scrollLeft = -(el.scrollWidth - scrollLeft);
        break;
    }
  }
  el.scrollLeft = scrollLeft;
}
var _rtlScrollSystem;
function getRtlScrollSystem() {
  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());
}
function detectRtlScrollSystem() {
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "-1000px";
  el.style.width = "100px";
  el.style.height = "100px";
  el.style.overflow = "scroll";
  el.style.direction = "rtl";
  let innerEl = document.createElement("div");
  innerEl.style.width = "200px";
  innerEl.style.height = "200px";
  el.appendChild(innerEl);
  document.body.appendChild(el);
  let system;
  if (el.scrollLeft > 0) {
    system = "positive";
  } else {
    el.scrollLeft = 1;
    if (el.scrollLeft > 0) {
      system = "reverse";
    } else {
      system = "negative";
    }
  }
  removeElement(el);
  return system;
}
var STICKY_SELECTOR = ".fc-sticky";
var StickyScrolling = class {
  constructor(scrollEl, isRtl) {
    this.scrollEl = scrollEl;
    this.isRtl = isRtl;
    this.updateSize = () => {
      let { scrollEl: scrollEl2 } = this;
      let els = findElements(scrollEl2, STICKY_SELECTOR);
      let elGeoms = this.queryElGeoms(els);
      let viewportWidth = scrollEl2.clientWidth;
      assignStickyPositions(els, elGeoms, viewportWidth);
    };
  }
  queryElGeoms(els) {
    let { scrollEl, isRtl } = this;
    let canvasOrigin = getScrollCanvasOrigin(scrollEl);
    let elGeoms = [];
    for (let el of els) {
      let parentBound = translateRect(
        computeInnerRect(el.parentNode, true, true),
        // weird way to call this!!!
        -canvasOrigin.left,
        -canvasOrigin.top
      );
      let elRect = el.getBoundingClientRect();
      let computedStyles = window.getComputedStyle(el);
      let textAlign = window.getComputedStyle(el.parentNode).textAlign;
      let naturalBound = null;
      if (textAlign === "start") {
        textAlign = isRtl ? "right" : "left";
      } else if (textAlign === "end") {
        textAlign = isRtl ? "left" : "right";
      }
      if (computedStyles.position !== "sticky") {
        naturalBound = translateRect(
          elRect,
          -canvasOrigin.left - (parseFloat(computedStyles.left) || 0),
          // could be 'auto'
          -canvasOrigin.top - (parseFloat(computedStyles.top) || 0)
        );
      }
      elGeoms.push({
        parentBound,
        naturalBound,
        elWidth: elRect.width,
        elHeight: elRect.height,
        textAlign
      });
    }
    return elGeoms;
  }
};
function assignStickyPositions(els, elGeoms, viewportWidth) {
  els.forEach((el, i) => {
    let { textAlign, elWidth, parentBound } = elGeoms[i];
    let parentWidth = parentBound.right - parentBound.left;
    let left;
    if (textAlign === "center" && parentWidth > viewportWidth) {
      left = (viewportWidth - elWidth) / 2;
    } else {
      left = "";
    }
    applyStyle(el, {
      left,
      right: left,
      top: 0
    });
  });
}
var ClippedScroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.state = {
      xScrollbarWidth: 0,
      yScrollbarWidth: 0
    };
    this.handleScroller = (scroller) => {
      this.scroller = scroller;
      setRef(this.props.scrollerRef, scroller);
    };
    this.handleSizing = () => {
      let { props } = this;
      if (props.overflowY === "scroll-hidden") {
        this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });
      }
      if (props.overflowX === "scroll-hidden") {
        this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();
    let overcomeLeft = 0;
    let overcomeRight = 0;
    let overcomeBottom = 0;
    let { overflowX, overflowY } = props;
    if (props.forPrint) {
      overflowX = "visible";
      overflowY = "visible";
    }
    if (overflowX === "scroll-hidden") {
      overcomeBottom = state.xScrollbarWidth;
    }
    if (overflowY === "scroll-hidden") {
      if (state.yScrollbarWidth != null) {
        if (isScrollbarOnLeft) {
          overcomeLeft = state.yScrollbarWidth;
        } else {
          overcomeRight = state.yScrollbarWidth;
        }
      }
    }
    return y(
      "div",
      { ref: this.elRef, className: "fc-scroller-harness" + (props.liquid ? " fc-scroller-harness-liquid" : "") },
      y(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === "scroll-hidden" ? "scroll" : overflowX, overflowY: overflowY === "scroll-hidden" ? "scroll" : overflowY, overcomeLeft, overcomeRight, overcomeBottom, maxHeight: typeof props.maxHeight === "number" ? props.maxHeight + (overflowX === "scroll-hidden" ? state.xScrollbarWidth : 0) : "", liquid: props.liquid, liquidIsAbsolute: true }, props.children)
    );
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  getSnapshotBeforeUpdate(prevProps) {
    if (this.props.forPrint && !prevProps.forPrint) {
      return { simulateScrollLeft: this.scroller.el.scrollLeft };
    }
    return {};
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    const { props, scroller: { el: scrollerEl } } = this;
    if (!isPropsEqual(prevProps, props)) {
      this.handleSizing();
    }
    if (snapshot.simulateScrollLeft !== void 0) {
      scrollerEl.style.left = -snapshot.simulateScrollLeft + "px";
    } else if (!props.forPrint && prevProps.forPrint) {
      const restoredScrollLeft = -parseInt(scrollerEl.style.left);
      scrollerEl.style.left = "";
      scrollerEl.scrollLeft = restoredScrollLeft;
    }
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  needsXScrolling() {
    return this.scroller.needsXScrolling();
  }
  needsYScrolling() {
    return this.scroller.needsYScrolling();
  }
};
var WHEEL_EVENT_NAMES = "wheel mousewheel DomMouseScroll MozMousePixelScroll".split(" ");
var ScrollListener = class {
  constructor(el) {
    this.el = el;
    this.emitter = new Emitter();
    this.isScrolling = false;
    this.isTouching = false;
    this.isRecentlyWheeled = false;
    this.isRecentlyScrolled = false;
    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));
    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));
    this.handleScroll = () => {
      this.startScroll();
      this.emitter.trigger("scroll", this.isRecentlyWheeled, this.isTouching);
      this.isRecentlyScrolled = true;
      this.scrollWaiter.request(500);
    };
    this.handleWheel = () => {
      this.isRecentlyWheeled = true;
      this.wheelWaiter.request(500);
    };
    this.handleTouchStart = () => {
      this.isTouching = true;
    };
    this.handleTouchEnd = () => {
      this.isTouching = false;
      if (!this.isRecentlyScrolled) {
        this.endScroll();
      }
    };
    el.addEventListener("scroll", this.handleScroll);
    el.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    el.addEventListener("touchend", this.handleTouchEnd);
    for (let eventName of WHEEL_EVENT_NAMES) {
      el.addEventListener(eventName, this.handleWheel);
    }
  }
  destroy() {
    let { el } = this;
    el.removeEventListener("scroll", this.handleScroll);
    el.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    el.removeEventListener("touchend", this.handleTouchEnd);
    for (let eventName of WHEEL_EVENT_NAMES) {
      el.removeEventListener(eventName, this.handleWheel);
    }
  }
  // Start / Stop
  // ----------------------------------------------------------------------------------------------
  startScroll() {
    if (!this.isScrolling) {
      this.isScrolling = true;
      this.emitter.trigger("scrollStart", this.isRecentlyWheeled, this.isTouching);
    }
  }
  endScroll() {
    if (this.isScrolling) {
      this.emitter.trigger("scrollEnd");
      this.isScrolling = false;
      this.isRecentlyScrolled = true;
      this.isRecentlyWheeled = false;
      this.scrollWaiter.clear();
      this.wheelWaiter.clear();
    }
  }
  _handleScrollWaited() {
    this.isRecentlyScrolled = false;
    if (!this.isTouching) {
      this.endScroll();
    }
  }
  _handleWheelWaited() {
    this.isRecentlyWheeled = false;
  }
};
var ScrollSyncer = class {
  constructor(isVertical, scrollEls) {
    this.isVertical = isVertical;
    this.scrollEls = scrollEls;
    this.isPaused = false;
    this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));
  }
  destroy() {
    for (let scrollListener of this.scrollListeners) {
      scrollListener.destroy();
    }
  }
  bindScroller(el) {
    let { scrollEls, isVertical } = this;
    let scrollListener = new ScrollListener(el);
    const onScroll = (isWheel, isTouch) => {
      if (!this.isPaused) {
        if (!this.masterEl || this.masterEl !== el && (isWheel || isTouch)) {
          this.assignMaster(el);
        }
        if (this.masterEl === el) {
          for (let otherEl of scrollEls) {
            if (otherEl !== el) {
              if (isVertical) {
                otherEl.scrollTop = el.scrollTop;
              } else {
                otherEl.scrollLeft = el.scrollLeft;
              }
            }
          }
        }
      }
    };
    const onScrollEnd = () => {
      if (this.masterEl === el) {
        this.masterEl = null;
      }
    };
    scrollListener.emitter.on("scroll", onScroll);
    scrollListener.emitter.on("scrollEnd", onScrollEnd);
    return scrollListener;
  }
  assignMaster(el) {
    this.masterEl = el;
    for (let scrollListener of this.scrollListeners) {
      if (scrollListener.el !== el) {
        scrollListener.endScroll();
      }
    }
  }
  /*
  will normalize the scrollLeft value
  */
  forceScrollLeft(scrollLeft) {
    this.isPaused = true;
    for (let listener of this.scrollListeners) {
      setScrollFromLeftEdge(listener.el, scrollLeft);
    }
    this.isPaused = false;
  }
  forceScrollTop(top) {
    this.isPaused = true;
    for (let listener of this.scrollListeners) {
      listener.el.scrollTop = top;
    }
    this.isPaused = false;
  }
};
config.SCROLLGRID_RESIZE_INTERVAL = 500;
var ScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);
    this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup);
    this.clippedScrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));
    this.scrollSyncersBySection = {};
    this.scrollSyncersByColumn = {};
    this.rowUnstableMap = /* @__PURE__ */ new Map();
    this.rowInnerMaxHeightMap = /* @__PURE__ */ new Map();
    this.anyRowHeightsChanged = false;
    this.recentSizingCnt = 0;
    this.state = {
      shrinkWidths: [],
      forceYScrollbars: false,
      forceXScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {},
      sectionRowMaxHeights: []
    };
    this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {
      if (!this.allowSizing()) {
        return;
      }
      if (!sectionRowMaxHeightsChanged) {
        this.anyRowHeightsChanged = true;
      }
      let otherState = {};
      if (isForcedResize || !sectionRowMaxHeightsChanged && !this.rowUnstableMap.size) {
        otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();
      }
      this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {
        if (!this.rowUnstableMap.size) {
          this.updateStickyScrolling();
        }
      });
    };
    this.handleRowHeightChange = (rowEl, isStable) => {
      let { rowUnstableMap, rowInnerMaxHeightMap } = this;
      if (!isStable) {
        rowUnstableMap.set(rowEl, true);
      } else {
        rowUnstableMap.delete(rowEl);
        let innerMaxHeight = getRowInnerMaxHeight(rowEl);
        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {
          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);
          this.anyRowHeightsChanged = true;
        }
        if (!rowUnstableMap.size && this.anyRowHeightsChanged) {
          this.anyRowHeightsChanged = false;
          this.setState({
            sectionRowMaxHeights: this.computeSectionRowMaxHeights()
          });
        }
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { shrinkWidths } = state;
    let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));
    let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));
    let classNames = getScrollGridClassNames(props.liquid, context);
    this.getDims();
    let sectionConfigs = props.sections;
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));
      configI += 1;
    }
    const isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      ref: props.elRef,
      role: "grid",
      className: classNames.join(" ")
    }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader)));
  }
  renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {
    if ("outerContent" in chunkConfig) {
      return y(_, { key: chunkConfig.key }, chunkConfig.outerContent);
    }
    let { state } = this;
    let { scrollerClientWidths, scrollerClientHeights } = state;
    let [sectionCnt, chunksPerSection] = this.getDims();
    let index3 = sectionIndex * chunksPerSection + chunkIndex;
    let sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;
    let isVScrollSide = chunkIndex === sideScrollIndex;
    let isLastSection = sectionIndex === sectionCnt - 1;
    let forceXScrollbars = isLastSection && state.forceXScrollbars;
    let forceYScrollbars = isVScrollSide && state.forceYScrollbars;
    let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling;
    let allowYScrolling = getAllowYScrolling(this.props, sectionConfig);
    let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig);
    let expandRows = sectionConfig.expandRows && chunkVGrow;
    let tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || "";
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth,
      clientWidth: scrollerClientWidths[index3] !== void 0 ? scrollerClientWidths[index3] : null,
      clientHeight: scrollerClientHeights[index3] !== void 0 ? scrollerClientHeights[index3] : null,
      expandRows,
      syncRowHeights: Boolean(sectionConfig.syncRowHeights),
      rowSyncHeights: rowHeights,
      reportRowHeightChange: this.handleRowHeightChange
    }, isHeader);
    let overflowX = forceXScrollbars ? isLastSection ? "scroll" : "scroll-hidden" : !allowXScrolling ? "hidden" : isLastSection ? "auto" : "scroll-hidden";
    let overflowY = forceYScrollbars ? isVScrollSide ? "scroll" : "scroll-hidden" : !allowYScrolling ? "hidden" : isVScrollSide ? "auto" : "scroll-hidden";
    content = y(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index3), scrollerElRef: this.scrollerElRefs.createRef(index3), overflowX, overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content);
    return y(isHeader ? "th" : "td", {
      key: chunkConfig.key,
      ref: this.chunkElRefs.createRef(index3),
      role: "presentation"
    }, content);
  }
  componentDidMount() {
    this.getStickyScrolling = memoizeArraylike(initStickyScrolling);
    this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);
    this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);
    this.updateScrollSyncers();
    this.handleSizing(false);
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate(prevProps, prevState) {
    this.updateScrollSyncers();
    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
    this.destroyScrollSyncers();
  }
  allowSizing() {
    let now = /* @__PURE__ */ new Date();
    if (!this.lastSizingDate || now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {
      this.lastSizingDate = now;
      this.recentSizingCnt = 0;
      return true;
    }
    return (this.recentSizingCnt += 1) <= 10;
  }
  computeShrinkWidths() {
    let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));
    let [sectionCnt, chunksPerSection] = this.getDims();
    let cnt = sectionCnt * chunksPerSection;
    let shrinkWidths = [];
    colGroupStats.forEach((colGroupStat, i) => {
      if (colGroupStat.hasShrinkCol) {
        let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection);
        shrinkWidths[i] = computeShrinkWidth(chunkEls);
      }
    });
    return shrinkWidths;
  }
  // has the side effect of grooming rowInnerMaxHeightMap
  // TODO: somehow short-circuit if there are no new height changes
  computeSectionRowMaxHeights() {
    let newHeightMap = /* @__PURE__ */ new Map();
    let [sectionCnt, chunksPerSection] = this.getDims();
    let sectionRowMaxHeights = [];
    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      let sectionConfig = this.props.sections[sectionI];
      let assignableHeights = [];
      if (sectionConfig && sectionConfig.syncRowHeights) {
        let rowHeightsByChunk = [];
        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
          let index3 = sectionI * chunksPerSection + chunkI;
          let rowHeights = [];
          let chunkEl = this.chunkElRefs.currentMap[index3];
          if (chunkEl) {
            rowHeights = findElements(chunkEl, ".fc-scrollgrid-sync-table tr").map((rowEl) => {
              let max = getRowInnerMaxHeight(rowEl);
              newHeightMap.set(rowEl, max);
              return max;
            });
          } else {
            rowHeights = [];
          }
          rowHeightsByChunk.push(rowHeights);
        }
        let rowCnt = rowHeightsByChunk[0].length;
        let isEqualRowCnt = true;
        for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {
          let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== void 0;
          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) {
            isEqualRowCnt = false;
            break;
          }
        }
        if (!isEqualRowCnt) {
          let chunkHeightSums = [];
          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);
          }
          let maxTotalSum = Math.max(...chunkHeightSums);
          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            let rowInChunkCnt = rowHeightsByChunk[chunkI].length;
            let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt;
            let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);
            let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);
            let rowInChunkHeights = [];
            let row = 0;
            if (row < rowInChunkCnt) {
              rowInChunkHeights.push(rowInChunkHeightFirst);
              row += 1;
            }
            while (row < rowInChunkCnt) {
              rowInChunkHeights.push(rowInChunkHeightOthers);
              row += 1;
            }
            assignableHeights.push(rowInChunkHeights);
          }
        } else {
          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
            assignableHeights.push([]);
          }
          for (let row = 0; row < rowCnt; row += 1) {
            let rowHeightsAcrossChunks = [];
            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
              let h = rowHeightsByChunk[chunkI][row];
              if (h != null) {
                rowHeightsAcrossChunks.push(h);
              }
            }
            let maxHeight = Math.max(...rowHeightsAcrossChunks);
            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
              assignableHeights[chunkI].push(maxHeight);
            }
          }
        }
      }
      sectionRowMaxHeights.push(assignableHeights);
    }
    this.rowInnerMaxHeightMap = newHeightMap;
    return sectionRowMaxHeights;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let [sectionCnt, chunksPerSection] = this.getDims();
    let sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;
    let lastSectionI = sectionCnt - 1;
    let currentScrollers = this.clippedScrollerRefs.currentMap;
    let scrollerEls = this.scrollerElRefs.currentMap;
    let forceYScrollbars = false;
    let forceXScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      let index3 = sectionI * chunksPerSection + sideScrollI;
      let scroller = currentScrollers[index3];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
      let index3 = lastSectionI * chunksPerSection + chunkI;
      let scroller = currentScrollers[index3];
      if (scroller && scroller.needsXScrolling()) {
        forceXScrollbars = true;
        break;
      }
    }
    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {
        let index3 = sectionI * chunksPerSection + chunkI;
        let scrollerEl = scrollerEls[index3];
        if (scrollerEl) {
          let harnessEl = scrollerEl.parentNode;
          scrollerClientWidths[index3] = Math.floor(harnessEl.getBoundingClientRect().width - (chunkI === sideScrollI && forceYScrollbars ? scrollbarWidth.y : 0));
          scrollerClientHeights[index3] = Math.floor(harnessEl.getBoundingClientRect().height - (sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x : 0));
        }
      }
    }
    return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
  updateStickyScrolling() {
    let { isRtl } = this.context;
    let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);
    this.getStickyScrolling(argsByKey).forEach((stickyScrolling) => stickyScrolling.updateSize());
  }
  updateScrollSyncers() {
    let [sectionCnt, chunksPerSection] = this.getDims();
    let cnt = sectionCnt * chunksPerSection;
    let scrollElsBySection = {};
    let scrollElsByColumn = {};
    let scrollElMap = this.scrollerElRefs.currentMap;
    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {
      let startIndex = sectionI * chunksPerSection;
      let endIndex = startIndex + chunksPerSection;
      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1);
    }
    for (let col = 0; col < chunksPerSection; col += 1) {
      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection);
    }
    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);
    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);
  }
  destroyScrollSyncers() {
    mapHash(this.scrollSyncersBySection, destroyScrollSyncer);
    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);
  }
  getChunkConfigByIndex(index3) {
    let chunksPerSection = this.getDims()[1];
    let sectionI = Math.floor(index3 / chunksPerSection);
    let chunkI = index3 % chunksPerSection;
    let sectionConfig = this.props.sections[sectionI];
    return sectionConfig && sectionConfig.chunks[chunkI];
  }
  forceScrollLeft(col, scrollLeft) {
    let scrollSyncer = this.scrollSyncersByColumn[col];
    if (scrollSyncer) {
      scrollSyncer.forceScrollLeft(scrollLeft);
    }
  }
  forceScrollTop(sectionI, scrollTop) {
    let scrollSyncer = this.scrollSyncersBySection[sectionI];
    if (scrollSyncer) {
      scrollSyncer.forceScrollTop(scrollTop);
    }
  }
  _handleChunkEl(chunkEl, key) {
    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));
    if (chunkConfig) {
      setRef(chunkConfig.elRef, chunkEl);
    }
  }
  _handleScrollerEl(scrollerEl, key) {
    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));
    if (chunkConfig) {
      setRef(chunkConfig.scrollerElRef, scrollerEl);
    }
  }
  getDims() {
    let sectionCnt = this.props.sections.length;
    let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;
    return [sectionCnt, chunksPerSection];
  }
};
ScrollGrid.addStateEquality({
  shrinkWidths: isArraysEqual,
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function sumNumbers(numbers) {
  let sum = 0;
  for (let n of numbers) {
    sum += n;
  }
  return sum;
}
function getRowInnerMaxHeight(rowEl) {
  let innerHeights = findElements(rowEl, ".fc-scrollgrid-sync-inner").map(getElHeight);
  if (innerHeights.length) {
    return Math.max(...innerHeights);
  }
  return 0;
}
function getElHeight(el) {
  return el.offsetHeight;
}
function renderMacroColGroup(colGroupStats, shrinkWidths) {
  let children = colGroupStats.map((colGroupStat, i) => {
    let width = colGroupStat.width;
    if (width === "shrink") {
      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1;
    }
    return (
      // eslint-disable-next-line react/jsx-key
      y("col", { style: { width } })
    );
  });
  return y("colgroup", {}, ...children);
}
function compileColGroupStat(colGroupConfig) {
  let totalColWidth = sumColProp(colGroupConfig.cols, "width");
  let totalColMinWidth = sumColProp(colGroupConfig.cols, "minWidth");
  let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);
  let allowXScrolling = colGroupConfig.width !== "shrink" && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);
  return {
    hasShrinkCol,
    totalColWidth,
    totalColMinWidth,
    allowXScrolling,
    cols: colGroupConfig.cols,
    width: colGroupConfig.width
  };
}
function sumColProp(cols, propName) {
  let total = 0;
  for (let col of cols) {
    let val = col[propName];
    if (typeof val === "number") {
      total += val * (col.span || 1);
    }
  }
  return total;
}
var COL_GROUP_STAT_EQUALITY = {
  cols: isColPropsEqual
};
function isColGroupStatsEqual(stat0, stat1) {
  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);
}
function initScrollSyncer(isVertical, ...scrollEls) {
  return new ScrollSyncer(isVertical, scrollEls);
}
function destroyScrollSyncer(scrollSyncer) {
  scrollSyncer.destroy();
}
function initStickyScrolling(scrollEl, isRtl) {
  return new StickyScrolling(scrollEl, isRtl);
}

// node_modules/@fullcalendar/timeline/internal.js
var MIN_AUTO_LABELS = 18;
var MAX_AUTO_SLOTS_PER_LABEL = 6;
var MAX_AUTO_CELLS = 200;
config.MAX_TIMELINE_SLOTS = 1e3;
var STOCK_SUB_DURATIONS = [
  { years: 1 },
  { months: 1 },
  { days: 1 },
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { minutes: 10 },
  { minutes: 5 },
  { minutes: 1 },
  { seconds: 30 },
  { seconds: 15 },
  { seconds: 10 },
  { seconds: 5 },
  { seconds: 1 },
  { milliseconds: 500 },
  { milliseconds: 100 },
  { milliseconds: 10 },
  { milliseconds: 1 }
];
function buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {
  let tDateProfile = {
    labelInterval: allOptions.slotLabelInterval,
    slotDuration: allOptions.slotDuration
  };
  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv);
  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);
  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);
  let input = allOptions.slotLabelFormat;
  let rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);
  tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));
  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);
  let largeUnit = null;
  if (!tDateProfile.isTimeScale) {
    const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    if (/year|month|week/.test(slotUnit)) {
      largeUnit = slotUnit;
    }
  }
  tDateProfile.largeUnit = largeUnit;
  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs("weeks", dateProfile, dateEnv) >= 2 && !allOptions.businessHours;
  let rawSnapDuration = allOptions.snapDuration;
  let snapDuration;
  let snapsPerSlot;
  if (rawSnapDuration) {
    snapDuration = createDuration(rawSnapDuration);
    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);
  }
  if (snapsPerSlot == null) {
    snapDuration = tDateProfile.slotDuration;
    snapsPerSlot = 1;
  }
  tDateProfile.snapDuration = snapDuration;
  tDateProfile.snapsPerSlot = snapsPerSlot;
  let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);
  let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);
  let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);
  if (tDateProfile.isTimeScale) {
    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);
    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);
  }
  tDateProfile.timeWindowMs = timeWindowMs;
  tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };
  let slotDates = [];
  let date = normalizedStart;
  while (date < normalizedEnd) {
    if (isValidDate2(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      slotDates.push(date);
    }
    date = dateEnv.add(date, tDateProfile.slotDuration);
  }
  tDateProfile.slotDates = slotDates;
  let snapIndex = -1;
  let snapDiff = 0;
  const snapDiffToIndex = [];
  const snapIndexToDiff = [];
  date = normalizedStart;
  while (date < normalizedEnd) {
    if (isValidDate2(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      snapIndex += 1;
      snapDiffToIndex.push(snapIndex);
      snapIndexToDiff.push(snapDiff);
    } else {
      snapDiffToIndex.push(snapIndex + 0.5);
    }
    date = dateEnv.add(date, tDateProfile.snapDuration);
    snapDiff += 1;
  }
  tDateProfile.snapDiffToIndex = snapDiffToIndex;
  tDateProfile.snapIndexToDiff = snapIndexToDiff;
  tDateProfile.snapCnt = snapIndex + 1;
  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;
  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);
  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);
  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);
  return tDateProfile;
}
function normalizeDate(date, tDateProfile, dateEnv) {
  let normalDate = date;
  if (!tDateProfile.isTimeScale) {
    normalDate = startOfDay(normalDate);
    if (tDateProfile.largeUnit) {
      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);
    }
  }
  return normalDate;
}
function normalizeRange(range, tDateProfile, dateEnv) {
  if (!tDateProfile.isTimeScale) {
    range = computeVisibleDayRange(range);
    if (tDateProfile.largeUnit) {
      let dayRange = range;
      range = {
        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),
        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)
      };
      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {
        range = {
          start: range.start,
          end: dateEnv.add(range.end, tDateProfile.slotDuration)
        };
      }
    }
  }
  return range;
}
function isValidDate2(date, tDateProfile, dateProfile, dateProfileGenerator) {
  if (dateProfileGenerator.isHiddenDay(date)) {
    return false;
  }
  if (tDateProfile.isTimeScale) {
    let day = startOfDay(date);
    let timeMs = date.valueOf() - day.valueOf();
    let ms = timeMs - asRoughMs(dateProfile.slotMinTime);
    ms = (ms % 864e5 + 864e5) % 864e5;
    return ms < tDateProfile.timeWindowMs;
  }
  return true;
}
function validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  if (tDateProfile.labelInterval) {
    const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);
    if (labelCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn("slotLabelInterval results in too many cells");
      tDateProfile.labelInterval = null;
    }
  }
  if (tDateProfile.slotDuration) {
    const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);
    if (slotCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn("slotDuration results in too many cells");
      tDateProfile.slotDuration = null;
    }
  }
  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {
    const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);
    if (slotsPerLabel === null || slotsPerLabel < 1) {
      console.warn("slotLabelInterval must be a multiple of slotDuration");
      tDateProfile.slotDuration = null;
    }
  }
}
function ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  let { labelInterval } = tDateProfile;
  if (!labelInterval) {
    let input;
    if (tDateProfile.slotDuration) {
      for (input of STOCK_SUB_DURATIONS) {
        const tryLabelInterval = createDuration(input);
        const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);
        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
          labelInterval = tryLabelInterval;
          break;
        }
      }
      if (!labelInterval) {
        labelInterval = tDateProfile.slotDuration;
      }
    } else {
      for (input of STOCK_SUB_DURATIONS) {
        labelInterval = createDuration(input);
        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);
        if (labelCnt >= MIN_AUTO_LABELS) {
          break;
        }
      }
    }
    tDateProfile.labelInterval = labelInterval;
  }
  return labelInterval;
}
function ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  let { slotDuration } = tDateProfile;
  if (!slotDuration) {
    const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv);
    for (let input of STOCK_SUB_DURATIONS) {
      const trySlotDuration = createDuration(input);
      const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);
      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
        slotDuration = trySlotDuration;
        break;
      }
    }
    if (slotDuration) {
      const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);
      if (slotCnt > MAX_AUTO_CELLS) {
        slotDuration = null;
      }
    }
    if (!slotDuration) {
      slotDuration = labelInterval;
    }
    tDateProfile.slotDuration = slotDuration;
  }
  return slotDuration;
}
function computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {
  let format1;
  let format2;
  const { labelInterval } = tDateProfile;
  let unit = greatestDurationDenominator(labelInterval).unit;
  const weekNumbersVisible = allOptions.weekNumbers;
  let format0 = format1 = format2 = null;
  if (unit === "week" && !weekNumbersVisible) {
    unit = "day";
  }
  switch (unit) {
    case "year":
      format0 = { year: "numeric" };
      break;
    case "month":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric" };
      }
      format1 = { month: "short" };
      break;
    case "week":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric" };
      }
      format1 = { week: "narrow" };
      break;
    case "day":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric", month: "long" };
      } else if (currentRangeAs("months", dateProfile, dateEnv) > 1) {
        format0 = { month: "long" };
      }
      if (weekNumbersVisible) {
        format1 = { week: "short" };
      }
      format2 = { weekday: "narrow", day: "numeric" };
      break;
    case "hour":
      if (weekNumbersVisible) {
        format0 = { week: "short" };
      }
      if (currentRangeAs("days", dateProfile, dateEnv) > 1) {
        format1 = { weekday: "short", day: "numeric", month: "numeric", omitCommas: true };
      }
      format2 = {
        hour: "numeric",
        minute: "2-digit",
        omitZeroMinute: true,
        meridiem: "short"
      };
      break;
    case "minute":
      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = {
          hour: "numeric",
          meridiem: "short"
        };
        format1 = (params) => ":" + padStart(params.date.minute, 2);
      } else {
        format0 = {
          hour: "numeric",
          minute: "numeric",
          meridiem: "short"
        };
      }
      break;
    case "second":
      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = { hour: "numeric", minute: "2-digit", meridiem: "lowercase" };
        format1 = (params) => ":" + padStart(params.date.second, 2);
      } else {
        format0 = { hour: "numeric", minute: "2-digit", second: "2-digit", meridiem: "lowercase" };
      }
      break;
    case "millisecond":
      format0 = { hour: "numeric", minute: "2-digit", second: "2-digit", meridiem: "lowercase" };
      format1 = (params) => "." + padStart(params.millisecond, 3);
      break;
  }
  return [].concat(format0 || [], format1 || [], format2 || []);
}
function currentRangeAs(unit, dateProfile, dateEnv) {
  let range = dateProfile.currentRange;
  let res = null;
  if (unit === "years") {
    res = dateEnv.diffWholeYears(range.start, range.end);
  } else if (unit === "months") {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === "weeks") {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === "days") {
    res = diffWholeDays(range.start, range.end);
  }
  return res || 0;
}
function buildIsWeekStarts(tDateProfile, dateEnv) {
  let { slotDates, emphasizeWeeks } = tDateProfile;
  let prevWeekNumber = null;
  let isWeekStarts = [];
  for (let slotDate of slotDates) {
    let weekNumber = dateEnv.computeWeekNumber(slotDate);
    let isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;
    prevWeekNumber = weekNumber;
    isWeekStarts.push(isWeekStart);
  }
  return isWeekStarts;
}
function buildCellRows(tDateProfile, dateEnv) {
  let slotDates = tDateProfile.slotDates;
  let formats = tDateProfile.headerFormats;
  let cellRows = formats.map(() => []);
  let slotAsDays = asCleanDays(tDateProfile.slotDuration);
  let guessedSlotUnit = slotAsDays === 7 ? "week" : slotAsDays === 1 ? "day" : null;
  let rowUnitsFromFormats = formats.map((format) => format.getLargestUnit ? format.getLargestUnit() : null);
  for (let i = 0; i < slotDates.length; i += 1) {
    let date = slotDates[i];
    let isWeekStart = tDateProfile.isWeekStarts[i];
    for (let row = 0; row < formats.length; row += 1) {
      let format = formats[row];
      let rowCells = cellRows[row];
      let leadingCell = rowCells[rowCells.length - 1];
      let isLastRow = row === formats.length - 1;
      let isSuperRow = formats.length > 1 && !isLastRow;
      let newCell = null;
      let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);
      if (isSuperRow) {
        let text = dateEnv.format(date, format);
        if (!leadingCell || leadingCell.text !== text) {
          newCell = buildCellObject(date, text, rowUnit);
        } else {
          leadingCell.colspan += 1;
        }
      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {
        let text = dateEnv.format(date, format);
        newCell = buildCellObject(date, text, rowUnit);
      } else {
        leadingCell.colspan += 1;
      }
      if (newCell) {
        newCell.weekStart = isWeekStart;
        rowCells.push(newCell);
      }
    }
  }
  return cellRows;
}
function buildCellObject(date, text, rowUnit) {
  return { date, text, rowUnit, colspan: 1, isWeekStart: false };
}
var TimelineHeaderTh = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
    this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);
  }
  render() {
    let { props, context } = this;
    let { dateEnv, options } = context;
    let { cell, dateProfile, tDateProfile } = props;
    let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);
    let renderProps = this.refineRenderProps({
      level: props.rowLevel,
      dateMarker: cell.date,
      text: cell.text,
      dateEnv: context.dateEnv,
      viewApi: context.viewApi
    });
    return y(ContentContainer, { elTag: "th", elClasses: [
      "fc-timeline-slot",
      "fc-timeline-slot-label",
      cell.isWeekStart && "fc-timeline-slot-em",
      ...// TODO: so slot classnames for week/month/bigger. see note above about rowUnit
      cell.rowUnit === "time" ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme)
    ], elAttrs: {
      colSpan: cell.colspan,
      "data-date": dateEnv.formatIso(cell.date, {
        omitTime: !tDateProfile.isTimeScale,
        omitTimeZoneOffset: true
      })
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timeline-slot-frame", style: { height: props.rowInnerHeight } },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-timeline-slot-cushion",
        "fc-scrollgrid-sync-inner",
        props.isSticky && "fc-sticky"
      ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })
    ));
  }
};
function buildCellNavLinkAttrs(context, cellDate, rowUnit) {
  return rowUnit && rowUnit !== "time" ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};
}
function renderInnerContent(renderProps) {
  return renderProps.text;
}
function refineRenderProps(input) {
  return {
    level: input.level,
    date: input.dateEnv.toDate(input.dateMarker),
    view: input.viewApi,
    text: input.text
  };
}
var TimelineHeaderRows = class extends BaseComponent {
  render() {
    let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;
    let { cellRows } = tDateProfile;
    return y(_, null, cellRows.map((rowCells, rowLevel) => {
      let isLast = rowLevel === cellRows.length - 1;
      let isChrono = tDateProfile.isTimeScale && isLast;
      let classNames = [
        "fc-timeline-header-row",
        isChrono ? "fc-timeline-header-row-chrono" : ""
      ];
      return (
        // eslint-disable-next-line react/no-array-index-key
        y("tr", { key: rowLevel, className: classNames.join(" ") }, rowCells.map((cell) => y(TimelineHeaderTh, { key: cell.date.toISOString(), cell, rowLevel, dateProfile, tDateProfile, todayRange, nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))
      );
    }));
  }
};
var TimelineCoords = class {
  constructor(slatRootEl, slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {
    this.slatRootEl = slatRootEl;
    this.dateProfile = dateProfile;
    this.tDateProfile = tDateProfile;
    this.dateEnv = dateEnv;
    this.isRtl = isRtl;
    this.outerCoordCache = new PositionCache(
      slatRootEl,
      slatEls,
      true,
      // isHorizontal
      false
    );
    this.innerCoordCache = new PositionCache(
      slatRootEl,
      findDirectChildren(slatEls, "div"),
      true,
      // isHorizontal
      false
    );
  }
  isDateInRange(date) {
    return rangeContainsMarker(this.dateProfile.currentRange, date);
  }
  // results range from negative width of area to 0
  dateToCoord(date) {
    let { tDateProfile } = this;
    let snapCoverage = this.computeDateSnapCoverage(date);
    let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;
    let slotIndex = Math.floor(slotCoverage);
    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);
    let partial = slotCoverage - slotIndex;
    let { innerCoordCache, outerCoordCache } = this;
    if (this.isRtl) {
      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);
    }
    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;
  }
  rangeToCoords(range) {
    return {
      start: this.dateToCoord(range.start),
      end: this.dateToCoord(range.end)
    };
  }
  durationToCoord(duration) {
    let { dateProfile, tDateProfile, dateEnv, isRtl } = this;
    let coord = 0;
    if (dateProfile) {
      let date = dateEnv.add(dateProfile.activeRange.start, duration);
      if (!tDateProfile.isTimeScale) {
        date = startOfDay(date);
      }
      coord = this.dateToCoord(date);
      if (!isRtl && coord) {
        coord += 1;
      }
    }
    return coord;
  }
  coordFromLeft(coord) {
    if (this.isRtl) {
      return this.outerCoordCache.originClientRect.width - coord;
    }
    return coord;
  }
  // returned value is between 0 and the number of snaps
  computeDateSnapCoverage(date) {
    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);
  }
};
function computeDateSnapCoverage(date, tDateProfile, dateEnv) {
  let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);
  if (snapDiff < 0) {
    return 0;
  }
  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {
    return tDateProfile.snapCnt;
  }
  let snapDiffInt = Math.floor(snapDiff);
  let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];
  if (isInt(snapCoverage)) {
    snapCoverage += snapDiff - snapDiffInt;
  } else {
    snapCoverage = Math.ceil(snapCoverage);
  }
  return snapCoverage;
}
function coordToCss(hcoord, isRtl) {
  if (hcoord === null) {
    return { left: "", right: "" };
  }
  if (isRtl) {
    return { right: hcoord, left: "" };
  }
  return { left: hcoord, right: "" };
}
function coordsToCss(hcoords, isRtl) {
  if (!hcoords) {
    return { left: "", right: "" };
  }
  if (isRtl) {
    return { right: hcoords.start, left: -hcoords.end };
  }
  return { left: hcoords.start, right: -hcoords.end };
}
var TimelineHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
  }
  render() {
    let { props, context } = this;
    let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;
    let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;
    return y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
      "div",
      { className: "fc-timeline-header", ref: this.rootElRef },
      y(
        "table",
        { "aria-hidden": true, className: "fc-scrollgrid-sync-table", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },
        props.tableColGroupNode,
        y(
          "tbody",
          null,
          y(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, rowInnerHeights: props.rowInnerHeights })
        )
      ),
      context.options.nowIndicator && // need to have a container regardless of whether the current view has a visible now indicator
      // because apparently removal of the element resets the scroll for some reasons (issue #5351).
      // this issue doesn't happen for the timeline body however (
      y("div", { className: "fc-timeline-now-indicator-container" }, slatCoords && slatCoords.isDateInRange(nowDate) && y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-arrow"], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))
    ));
  }
  componentDidMount() {
    this.updateSize();
  }
  componentDidUpdate() {
    this.updateSize();
  }
  updateSize() {
    if (this.props.onMaxCushionWidth) {
      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());
    }
  }
  computeMaxCushionWidth() {
    return Math.max(...findElements(this.rootElRef.current, ".fc-timeline-header-row:last-child .fc-timeline-slot-cushion").map((el) => el.getBoundingClientRect().width));
  }
};
var TimelineSlatCell = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { dateEnv, options, theme } = context;
    let { date, tDateProfile, isEm } = props;
    let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);
    let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });
    return y(ContentContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timeline-slot",
      "fc-timeline-slot-lane",
      isEm && "fc-timeline-slot-em",
      tDateProfile.isTimeScale ? isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? "fc-timeline-slot-major" : "fc-timeline-slot-minor" : "",
      ...props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme)
    ], elAttrs: {
      "data-date": dateEnv.formatIso(date, {
        omitTimeZoneOffset: true,
        omitTime: !tDateProfile.isTimeScale
      })
    }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div" }));
  }
};
var TimelineSlatsBody = class extends BaseComponent {
  render() {
    let { props } = this;
    let { tDateProfile, cellElRefs } = props;
    let { slotDates, isWeekStarts } = tDateProfile;
    let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;
    return y(
      "tbody",
      null,
      y("tr", null, slotDates.map((slotDate, i) => {
        let key = slotDate.toISOString();
        return y(TimelineSlatCell, { key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay });
      }))
    );
  }
};
var TimelineSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
    this.handleScrollRequest = (request) => {
      let { onScrollLeftRequest } = this.props;
      let { coords } = this;
      if (onScrollLeftRequest && coords) {
        if (request.time) {
          let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));
          onScrollLeftRequest(scrollLeft);
        }
        return true;
      }
      return null;
    };
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { className: "fc-timeline-slots", ref: this.rootElRef },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.updateSizing();
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { props, context } = this;
    if (props.clientWidth !== null && // is sizing stable?
    this.scrollResponder) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetWidth) {
        this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);
        if (props.onCoords) {
          props.onCoords(this.coords);
        }
        this.scrollResponder.update(false);
      }
    }
  }
  positionToHit(leftPosition) {
    let { outerCoordCache } = this.coords;
    let { dateEnv, isRtl } = this.context;
    let { tDateProfile } = this.props;
    let slatIndex = outerCoordCache.leftToIndex(leftPosition);
    if (slatIndex != null) {
      let slatWidth = outerCoordCache.getWidth(slatIndex);
      let partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;
      let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);
      let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));
      let end = dateEnv.add(start, tDateProfile.snapDuration);
      return {
        dateSpan: {
          range: { start, end },
          allDay: !this.props.tDateProfile.isTimeScale
        },
        dayEl: this.cellElRefs.currentMap[slatIndex],
        left: outerCoordCache.lefts[slatIndex],
        right: outerCoordCache.rights[slatIndex]
      };
    }
    return null;
  }
};
function collectCellEls(elMap, slotDates) {
  return slotDates.map((slotDate) => {
    let key = slotDate.toISOString();
    return elMap[key];
  });
}
function computeSegHCoords(segs, minWidth, timelineCoords) {
  let hcoords = [];
  if (timelineCoords) {
    for (let seg of segs) {
      let res = timelineCoords.rangeToCoords(seg);
      let start = Math.round(res.start);
      let end = Math.round(res.end);
      if (end - start < minWidth) {
        end = start + minWidth;
      }
      hcoords.push({ start, end });
    }
  }
  return hcoords;
}
function computeFgSegPlacements(segs, segHCoords, eventInstanceHeights, moreLinkHeights, strictOrder, maxStackCnt) {
  let segInputs = [];
  let crudePlacements = [];
  for (let i = 0; i < segs.length; i += 1) {
    let seg = segs[i];
    let instanceId = seg.eventRange.instance.instanceId;
    let height = eventInstanceHeights[instanceId];
    let hcoords = segHCoords[i];
    if (height && hcoords) {
      segInputs.push({
        index: i,
        span: hcoords,
        thickness: height
      });
    } else {
      crudePlacements.push({
        seg,
        hcoords,
        top: null
      });
    }
  }
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenPlacements = hiddenEntries.map((entry) => ({
    seg: segs[entry.index],
    hcoords: entry.span,
    top: null
  }));
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let moreLinkInputs = [];
  let moreLinkCrudePlacements = [];
  const extractSeg = (entry) => segs[entry.index];
  for (let i = 0; i < hiddenGroups.length; i += 1) {
    let hiddenGroup = hiddenGroups[i];
    let sortedSegs = hiddenGroup.entries.map(extractSeg);
    let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))];
    if (height != null) {
      moreLinkInputs.push({
        index: segs.length + i,
        thickness: height,
        span: hiddenGroup.span
      });
    } else {
      moreLinkCrudePlacements.push({
        seg: sortedSegs,
        hcoords: hiddenGroup.span,
        top: null
      });
    }
  }
  hierarchy.maxStackCnt = -1;
  hierarchy.addSegs(moreLinkInputs);
  let visibleRects = hierarchy.toRects();
  let visiblePlacements = [];
  let maxHeight = 0;
  for (let rect of visibleRects) {
    let segIndex = rect.index;
    visiblePlacements.push({
      seg: segIndex < segs.length ? segs[segIndex] : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),
      hcoords: rect.span,
      top: rect.levelCoord
    });
    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);
  }
  return [
    visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),
    maxHeight
  ];
}
var TimelineLaneBg = class extends BaseComponent {
  render() {
    let { props } = this;
    let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);
    return props.timelineCoords && y(
      "div",
      { className: "fc-timeline-bg" },
      this.renderSegs(props.businessHourSegs || [], props.timelineCoords, "non-business"),
      this.renderSegs(props.bgEventSegs || [], props.timelineCoords, "bg-event"),
      this.renderSegs(highlightSeg, props.timelineCoords, "highlight")
    );
  }
  renderSegs(segs, timelineCoords, fillType) {
    let { todayRange, nowDate } = this.props;
    let { isRtl } = this.context;
    let segHCoords = computeSegHCoords(segs, 0, timelineCoords);
    let children = segs.map((seg, i) => {
      let hcoords = segHCoords[i];
      let hStyle = coordsToCss(hcoords, isRtl);
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timeline-bg-harness", style: hStyle }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
};
var TimelineLaneSlicer = class extends Slicer {
  sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {
    let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);
    let segs = [];
    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {
      let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);
      if (slicedRange) {
        segs.push({
          start: slicedRange.start,
          end: slicedRange.end,
          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate2(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),
          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate2(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)
        });
      }
    }
    return segs;
  }
};
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
var TimelineEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-timeline-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale }));
  }
};
var TimelineLaneMoreLink = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { hiddenSegs, placement, resourceId } = props;
    let { top, hcoords } = placement;
    let isVisible = hcoords && top !== null;
    let hStyle = coordsToCss(hcoords, context.isRtl);
    let extraDateSpan = resourceId ? { resourceId } : {};
    return y(MoreLinkContainer, { elRef: props.elRef, elClasses: ["fc-timeline-more-link"], elStyle: Object.assign({ visibility: isVisible ? "" : "hidden", top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan, popoverContent: () => y(_, null, hiddenSegs.map((seg) => {
      let instanceId = seg.eventRange.instance.instanceId;
      return y(
        "div",
        { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? "hidden" : "" } },
        y(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))
      );
    })) }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timeline-more-link-inner", "fc-sticky"] }));
  }
};
var TimelineLane = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.slicer = new TimelineLaneSlicer();
    this.sortEventSegs = memoize(sortEventSegs);
    this.harnessElRefs = new RefMap();
    this.moreElRefs = new RefMap();
    this.innerElRef = d();
    this.state = {
      eventInstanceHeights: {},
      moreLinkHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSize();
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let { dateProfile, tDateProfile } = props;
    let slicedProps = this.slicer.sliceProps(
      props,
      dateProfile,
      tDateProfile.isTimeScale ? null : props.nextDayThreshold,
      context,
      // wish we didn't have to pass in the rest of the args...
      dateProfile,
      context.dateProfileGenerator,
      tDateProfile,
      context.dateEnv
    );
    let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];
    let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);
    let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);
    let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);
    let isForcedInvisible = (
      // TODO: more convenient
      (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {}
    );
    return y(
      _,
      null,
      y(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [], dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),
      y(
        "div",
        { className: "fc-timeline-events fc-scrollgrid-sync-inner", ref: this.innerElRef, style: { height: fgHeight } },
        this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),
        this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)
      )
    );
  }
  componentDidMount() {
    this.updateSize();
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.eventStore !== this.props.eventStore || // external thing changed?
    prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?
    prevState.moreLinkHeights !== this.state.moreLinkHeights) {
      this.updateSize();
    }
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateSize() {
    let { props } = this;
    let { timelineCoords } = props;
    const innerEl = this.innerElRef.current;
    if (props.onHeightChange) {
      props.onHeightChange(innerEl, false);
    }
    if (timelineCoords) {
      this.setState({
        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => Math.round(harnessEl.getBoundingClientRect().height)),
        moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => Math.round(moreEl.getBoundingClientRect().height))
      }, () => {
        if (props.onHeightChange) {
          props.onHeightChange(innerEl, true);
        }
      });
    }
    if (props.syncParentMinHeight) {
      innerEl.parentElement.style.minHeight = innerEl.style.height;
    }
  }
  renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { harnessElRefs, moreElRefs, props, context } = this;
    let isMirror = isDragging || isResizing || isDateSelecting;
    return y(_, null, segPlacements.map((segPlacement) => {
      let { seg, hcoords, top } = segPlacement;
      if (Array.isArray(seg)) {
        let isoStr = buildIsoString(computeEarliestSegStart(seg));
        return y(TimelineLaneMoreLink, { key: "m:" + isoStr, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible });
      }
      let instanceId = seg.eventRange.instance.instanceId;
      let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);
      let hStyle = coordsToCss(hcoords, context.isRtl);
      return y(
        "div",
        { key: "e:" + instanceId, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: "fc-timeline-event-harness", style: Object.assign({ visibility: isVisible ? "" : "hidden", top: top || 0 }, hStyle) },
        y(TimelineEvent, Object.assign({
          isTimeScale: props.tDateProfile.isTimeScale,
          seg,
          isDragging,
          isResizing,
          isDateSelecting,
          isSelected: instanceId === props.eventSelection
          /* TODO: bad for mirror? */
        }, getSegMeta(seg, props.todayRange, props.nowDate)))
      );
    }));
  }
};
TimelineLane.addStateEquality({
  eventInstanceHeights: isPropsEqual,
  moreLinkHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {
  if (!mirrorSegs.length || !timelineCoords) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(fgPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    hcoords: timelineCoords.rangeToCoords(seg),
    top: topsByInstanceId[seg.eventRange.instance.instanceId]
  }));
}
function buildAbsoluteTopHash(placements) {
  let topsByInstanceId = {};
  for (let placement of placements) {
    let { seg } = placement;
    if (!Array.isArray(seg)) {
      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;
    }
  }
  return topsByInstanceId;
}
var TimelineGrid = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slatsRef = d();
    this.state = {
      coords: null
    };
    this.handeEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, { el });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleCoords = (coords) => {
      this.setState({ coords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(coords);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let { dateProfile, tDateProfile } = props;
    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    return y(
      "div",
      { className: "fc-timeline-body", ref: this.handeEl, style: {
        minWidth: props.tableMinWidth,
        height: props.clientHeight,
        width: props.clientWidth
      } },
      y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
        _,
        null,
        y(TimelineSlats, { ref: this.slatsRef, dateProfile, tDateProfile, nowDate, todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),
        y(TimelineLane, { dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),
        options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && y(
          "div",
          { className: "fc-timeline-now-indicator-container" },
          y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-line"], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate })
        )
      ))
    );
  }
  // Hit System
  // ------------------------------------------------------------------------------------------
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let slats = this.slatsRef.current;
    let slatHit = slats.positionToHit(positionLeft);
    if (slatHit) {
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: slatHit.dateSpan,
        rect: {
          left: slatHit.left,
          right: slatHit.right,
          top: 0,
          bottom: elHeight
        },
        dayEl: slatHit.dayEl,
        layer: 0
      };
    }
    return null;
  }
};
var TimelineView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    this.scrollGridRef = d();
    this.state = {
      slatCoords: null,
      slotCushionMaxWidth: null
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
    this.handleScrollLeftRequest = (scrollLeft) => {
      let scrollGrid = this.scrollGridRef.current;
      scrollGrid.forceScrollLeft(0, scrollLeft);
    };
    this.handleMaxCushionWidth = (slotCushionMaxWidth) => {
      this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth)
        // for less rerendering TODO: DRY
      });
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    let { slotMinWidth } = options;
    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    let sections = [
      {
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "timeline",
          content: (contentArg) => y(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })
        }]
      },
      {
        type: "body",
        key: "body",
        liquid: true,
        chunks: [{
          key: "timeline",
          content: (contentArg) => y(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))
        }]
      }
    ];
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "timeline",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: [
        "fc-timeline",
        options.eventOverlap === false ? "fc-timeline-overlap-disabled" : ""
      ], viewSpec: context.viewSpec },
      y(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { cols: slatCols }
      ], sections })
    );
  }
  computeFallbackSlotMinWidth(tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  }
};
function buildSlatCols(tDateProfile, slotMinWidth) {
  return [{
    span: tDateProfile.slotCnt,
    minWidth: slotMinWidth || 1
    // needs to be a non-zero number to trigger horizontal scrollbars!??????
  }];
}
var css_248z = '.fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:"";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}';
injectStyles(css_248z);

// node_modules/@fullcalendar/timeline/index.js
var index2 = createPlugin({
  name: "@fullcalendar/timeline",
  premiumReleaseDate: "2024-07-12",
  deps: [index],
  initialView: "timelineDay",
  views: {
    timeline: {
      component: TimelineView,
      usesMinMaxTime: true,
      eventResizableFromStart: true
      // how is this consumed for TimelineView tho?
    },
    timelineDay: {
      type: "timeline",
      duration: { days: 1 }
    },
    timelineWeek: {
      type: "timeline",
      duration: { weeks: 1 }
    },
    timelineMonth: {
      type: "timeline",
      duration: { months: 1 }
    },
    timelineYear: {
      type: "timeline",
      duration: { years: 1 }
    }
  }
});
export {
  index2 as default
};
//# sourceMappingURL=@fullcalendar_timeline.js.map
